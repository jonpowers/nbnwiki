<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/pool2/README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#pool2">Pool2</a>
      </div>

      <div class="heading h2">
        <a href="#usage">Usage</a>
      </div>

      <div class="heading h2">
        <a href="#constructor-options">Constructor options</a>
      </div>

      <div class="heading h3">
        <a href="#acquire">acquire</a>
      </div>

      <div class="heading h3">
        <a href="#acquiretimeout">acquireTimeout</a>
      </div>

      <div class="heading h3">
        <a href="#dispose">dispose</a>
      </div>

      <div class="heading h3">
        <a href="#disposetimeout">disposeTimeout</a>
      </div>

      <div class="heading h3">
        <a href="#destroy">destroy</a>
      </div>

      <div class="heading h3">
        <a href="#ping">ping</a>
      </div>

      <div class="heading h3">
        <a href="#pingtimeout">pingTimeout</a>
      </div>

      <div class="heading h3">
        <a href="#capabilities">capabilities</a>
      </div>

      <div class="heading h3">
        <a href="#min">min</a>
      </div>

      <div class="heading h3">
        <a href="#max">max</a>
      </div>

      <div class="heading h3">
        <a href="#maxrequests">maxRequests</a>
      </div>

      <div class="heading h3">
        <a href="#requesttimeout">requestTimeout</a>
      </div>

      <div class="heading h3">
        <a href="#idletimeout">idleTimeout</a>
      </div>

      <div class="heading h3">
        <a href="#syncinterval">syncInterval</a>
      </div>

      <div class="heading h3">
        <a href="#backoff">backoff</a>
      </div>

      <div class="heading h3">
        <a href="#bailafter">bailAfter</a>
      </div>

      <div class="heading h2">
        <a href="#instance-methods">Instance methods</a>
      </div>

      <div class="heading h3">
        <a href="#pool.acquire">pool.acquire()</a>
      </div>

      <div class="heading h3">
        <a href="#pool.remove">pool.remove()</a>
      </div>

      <div class="heading h3">
        <a href="#pool.destroy">pool.destroy()</a>
      </div>

      <div class="heading h3">
        <a href="#pool.stats">pool.stats()</a>
      </div>

      <div class="heading h3">
        <a href="#pool.end">pool.end()</a>
      </div>

      <div class="heading h3">
        <a href="#pool._destroypool">pool._destroyPool()</a>
      </div>

      <div class="heading h2">
        <a href="#clustering">Clustering</a>
      </div>

      <div class="heading h2">
        <a href="#constructor-options-1">Constructor options</a>
      </div>

      <div class="heading h2">
        <a href="#instance-methods-1">Instance methods</a>
      </div>

      <div class="heading h3">
        <a href="#cluster.addpool">cluster.addPool()</a>
      </div>

      <div class="heading h3">
        <a href="#cluster.removepool">cluster.removePool()</a>
      </div>

      <div class="heading h3">
        <a href="#cluster.pools">cluster.pools</a>
      </div>

      <div class="heading h3">
        <a href="#cluster.acquire-callback">cluster.acquire(callback)</a>
      </div>

      <div class="heading h3">
        <a href="#cluster.acquire-capability-callback">cluster.acquire(&#39;capability&#39;, callback)</a>
      </div>

      <div class="heading h3">
        <a href="#cluster.end">cluster.end()</a>
      </div>

      <div class="heading h2">
        <a href="#debugging">Debugging</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><div class="pilwrap" id="pool2">
  <h1>
    <a href="#pool2" name="pool2" class="pilcrow"></a>
Pool2
  </h1>
</div>
<p>A generic resource pool</p>
<div class="pilwrap" id="usage">
  <h2>
    <a href="#usage" name="usage" class="pilcrow"></a>
Usage
  </h2>
</div>
<p>The values below are the defaults</p>
<pre><code>var Pool = require('pool2');
var pool = new Pool({
    acquire: function (cb) { cb(null, resource); },
    acquireTimeout: 30*1000, // please see note below

    dispose: function (res, cb) { cb(); },
    disposeTimeout: 30*1000,

    destroy: function (res) { },

    ping: function (res, cb) { cb(); },
    pingTimeout: 10*1000,

    capabilities: ['tags'],

    min: 0,
    max: 10,

    maxRequests: Infinity,
    requestTimeout: Infinity,

    idleTimeout: 60*1000,
    syncInterval: 10*1000,

    backoff: { },
    bailAfter: 0
});

pool.acquire(function (err, rsrc) {
    // do stuff
    pool.release(rsrc);
});

pool.stats();
/* {
    min: 0,
    max: 10,
    allocated: 0,
    available: 0,
    queued: 0,
    maxRequests: Infinity
} */

pool.remove(rsrc);
pool.destroy(rsrc);

pool.end(function (errs) {
    // errs is null or an array of errors from resources that were released
});

pool._destroyPool();
</code></pre>
<div class="pilwrap" id="constructor-options">
  <h2>
    <a href="#constructor-options" name="constructor-options" class="pilcrow"></a>
Constructor options
  </h2>
</div>
<div class="pilwrap" id="acquire">
  <h3>
    <a href="#acquire" name="acquire" class="pilcrow"></a>
acquire
  </h3>
</div>
<p>Required. The function that acquires a resource (e.g. opens a database connection) on behalf of the pool. Accepts a node-style callback.</p>
<div class="pilwrap" id="acquiretimeout">
  <h3>
    <a href="#acquiretimeout" name="acquiretimeout" class="pilcrow"></a>
acquireTimeout
  </h3>
</div>
<p>An integer, in milliseconds, to specify how long to wait for a call to <code>acquire</code> before failing.</p>
<p><strong>NOTE</strong>: <code>acquireTimeout</code> is the delay after which <code>pool2</code> will stop waiting for a resource and move on with its life. This means that it's possible for in-flight resources that have timed out to remain open and exceed the pool maximum. Resources that complete allocation that have timed out this way will have the disposer called on them.</p>
<p>If what you want is for something, e.g. a database connection, or http request, to be <em>destroyed</em> after some timeout, you probably want something like this, instead:</p>
<pre><code class="javascript">  acquire: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb</span>) </span>{
    openThing({ <span class="hljs-attr">timeout</span>: <span class="hljs-number">2000</span> })
      .on(<span class="hljs-string">'timeout'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        cb(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Timed out'</span>));
      });
  }
</code></pre>
<p>This puts the burden of timing out and cleaning up on the library for the resource you are using pool2 to manage; you then <em>react</em> to the timeout event and notify pool2 of the failure to acquire the resource.</p>
<div class="pilwrap" id="dispose">
  <h3>
    <a href="#dispose" name="dispose" class="pilcrow"></a>
dispose
  </h3>
</div>
<p>Required. The function that disposes of a resource (e.g. gracefully closes a database connection) on behalf of the pool. Accepts the resource to dispose of, which is the same object returned by the acquire function, and a node-style callback.</p>
<div class="pilwrap" id="disposetimeout">
  <h3>
    <a href="#disposetimeout" name="disposetimeout" class="pilcrow"></a>
disposeTimeout
  </h3>
</div>
<p>An integer, in milliseconds, to specify how long to wait for a call to <code>dispose</code> before failing. Resources that fail the <code>dispose</code> call will still be removed from the pool, but undefined behavior may occur: if a dispose call fails, it may leave dangling sockets or handles that prevent graceful exit of an application.</p>
<div class="pilwrap" id="destroy">
  <h3>
    <a href="#destroy" name="destroy" class="pilcrow"></a>
destroy
  </h3>
</div>
<p>Optional. This function is called with a resource that is destroyed, either by a timeout or failed call to <code>dispose</code>, or an explicit call to <code>pool.destroy()</code>. There is no node-style callback: this function is a last resort, and is fire-and-forget.</p>
<div class="pilwrap" id="ping">
  <h3>
    <a href="#ping" name="ping" class="pilcrow"></a>
ping
  </h3>
</div>
<p>Optional. A function to check whether a resource is still alive (e.g. send <code>SELECT 1</code> on a database connection). Accepts the resource to test and a node-style callback.</p>
<div class="pilwrap" id="pingtimeout">
  <h3>
    <a href="#pingtimeout" name="pingtimeout" class="pilcrow"></a>
pingTimeout
  </h3>
</div>
<p>An integer, in milliseconds, to specify how long to wait for the <code>ping</code> function before giving up and disposing of the resource.</p>
<div class="pilwrap" id="capabilities">
  <h3>
    <a href="#capabilities" name="capabilities" class="pilcrow"></a>
capabilities
  </h3>
</div>
<p>An array of strings. This is used in conjunction with clustering to specify which pools in the cluster to select from. For example, you might have a pool of connections to a database master with read-write capability, and another pool of connections to a slave with read-only capability. One would be defined as <code>capabilities: ['read', 'write']</code>, and the other as <code>capabilities: ['read']</code>. When acquiring from the cluster, you could use <code>cluster.acquire('read', ...)</code> and be served a connection from either pool, but if you used <code>cluster.acquire('write', ...)</code>, you would only receive connections from the master (read-write) pool.</p>
<div class="pilwrap" id="min">
  <h3>
    <a href="#min" name="min" class="pilcrow"></a>
min
  </h3>
</div>
<p>An integer greater than zero. The minimum number of resources to maintain in the pool. If the pool contains fewer resources than this, it will attempt to acquire more until it reaches this value.</p>
<div class="pilwrap" id="max">
  <h3>
    <a href="#max" name="max" class="pilcrow"></a>
max
  </h3>
</div>
<p>An integer greater than or equal to <code>min</code>. The maximum number of resources the pool may contain. Requests for resources will not cause new resources to be allocated when this number of resources are currently held in the pool (whether checked out or not). If all resources are checked out, requests are queued until one becomes available.</p>
<div class="pilwrap" id="maxrequests">
  <h3>
    <a href="#maxrequests" name="maxrequests" class="pilcrow"></a>
maxRequests
  </h3>
</div>
<p>An integer greater than 0 (<code>Infinity</code> is also valid), to specify the maximum number of requests that the pool instance will allow. If the request queue exceeds this number, calls to <code>acquire</code> will fail with the error <code>Pool is full</code>.</p>
<div class="pilwrap" id="requesttimeout">
  <h3>
    <a href="#requesttimeout" name="requesttimeout" class="pilcrow"></a>
requestTimeout
  </h3>
</div>
<p>An integer, in milliseconds (<code>Infinity</code> is also valid), to specify how long to wait for a successful resource request before failing.</p>
<div class="pilwrap" id="idletimeout">
  <h3>
    <a href="#idletimeout" name="idletimeout" class="pilcrow"></a>
idleTimeout
  </h3>
</div>
<p>An integer, in milliseconds, to specify how long a resource must be idle before it may be disposed of. Resources are periodically checked (see <code>syncInterval</code> below) for idleness, and idle resources are disposed of unless they would bring the pool below the configured <code>min</code> value.</p>
<div class="pilwrap" id="syncinterval">
  <h3>
    <a href="#syncinterval" name="syncinterval" class="pilcrow"></a>
syncInterval
  </h3>
</div>
<p>An integer, in milliseconds, to specify how often to dispose of idle resources and/or open new resources to fulfill the pool minimum.</p>
<div class="pilwrap" id="backoff">
  <h3>
    <a href="#backoff" name="backoff" class="pilcrow"></a>
backoff
  </h3>
</div>
<p>An object, passed as-is to <a href="https://www.npmjs.com/package/simple-backoff">simple-backoff</a>, which governs the retry rate for failed allocations. <code>pool2</code> uses the Fibonacci strategy for backoff timing. Currently only an explicit failure or timeout on an allocation is retried in this fashion; all other errors and removals of resources that may cause the pool's resource collection to fall under the minimum are remedied on the <code>syncInterval</code> or an explicit allocation request when no resources are available.</p>
<div class="pilwrap" id="bailafter">
  <h3>
    <a href="#bailafter" name="bailafter" class="pilcrow"></a>
bailAfter
  </h3>
</div>
<p>An integer, in milliseconds (<code>Infinity</code> is also valid), to specify how long to wait for a successful allocation before failing. <code>pool2</code> has a concept of whether a pool is &quot;live&quot;, defined by whether it has succeeded in allocating <em>any</em> resource yet. When a pool is initialized, its <code>live</code> property is set to <code>false</code>, and a timestamp is taken. When an allocation succeeds, the <code>live</code> property is set to true. When an allocation fails, if <code>live</code> is <code>false</code>, the difference between the current timestamp and the initial timestamp is taken: if this value is greater than <code>bailAfter</code>, the pool is destroyed and an error is emitted.</p>
<p>The primary purpose of this functionality is to allow for applications to crash and notify the user when configuration is incorrect or some other problem occurs (database isn't started, network configuration has changed, etc.)</p>
<p>The default for this value is 0, meaning that if the <em>very first</em> allocation request fails, pool2 will fail. <code>Infinity</code> is an acceptable value, allowing you to retry infinitely. Retries follow the backoff settings, if supplied, though an extra try or two may result from the <code>syncInterval</code> setting as well.</p>
<div class="pilwrap" id="instance-methods">
  <h2>
    <a href="#instance-methods" name="instance-methods" class="pilcrow"></a>
Instance methods
  </h2>
</div>
<div class="pilwrap" id="pool.acquire">
  <h3>
    <a href="#pool.acquire" name="pool.acquire" class="pilcrow"></a>
pool.acquire()
  </h3>
</div>
<p>Acquire a resource from the pool. Accepts a node-style callback, which is given either the resource or an error. Calls to acquire are queued and served in first in, first out order. Currently, acquire requests are queued indefinitely. Requests are subject to the <code>maxRequests</code> option; if the queue is full, a call to <code>acquire</code> will be rejected with the error <code>Pool is full</code>.</p>
<div class="pilwrap" id="pool.remove">
  <h3>
    <a href="#pool.remove" name="pool.remove" class="pilcrow"></a>
pool.remove()
  </h3>
</div>
<p>Remove a resource from the pool gracefully. This method should be preferred over <code>destroy</code> (see below). This method is fire-and-forget: it does not take a callback, even though the underlying <code>dispose</code> function does.</p>
<div class="pilwrap" id="pool.destroy">
  <h3>
    <a href="#pool.destroy" name="pool.destroy" class="pilcrow"></a>
pool.destroy()
  </h3>
</div>
<p>Remove a resource from the pool &quot;ungracefully&quot;. This immediately removes the resource without attempting to clean it up. Suitable for removing resources that encounter a fatal error and cannot otherwise be nicely dealt with.</p>
<div class="pilwrap" id="pool.stats">
  <h3>
    <a href="#pool.stats" name="pool.stats" class="pilcrow"></a>
pool.stats()
  </h3>
</div>
<p>Returns some information about the current state of the pool:</p>
<pre><code>{
    min: 0,
    max: 10,
    allocated: 0,
    available: 0,
    queued: 0,
    maxRequests: Infinity
}
</code></pre>
<div class="pilwrap" id="pool.end">
  <h3>
    <a href="#pool.end" name="pool.end" class="pilcrow"></a>
pool.end()
  </h3>
</div>
<p>Attempt to gracefully shut everything down. Calls to <code>acquire</code> after calling <code>end</code> will be rejected with the error <code>Pool is ending</code> (or <code>Pool is destroyed</code> once shutdown has completed). Pending resources will not be disposed of until they are released by whatever has checked them out. When all resources have been released back to the pool, calls the <code>dispose</code> function on each of them and collects any errors. These errors are passed along to the callback, if provided.</p>
<p>Example:</p>
<pre><code>pool.end(function (errors) {
    if (!errors.length) { return; }
    console.error('Encountered some errors while shutting down:', errors);
});
</code></pre>
<div class="pilwrap" id="pool._destroypool">
  <h3>
    <a href="#pool._destroypool" name="pool._destroypool" class="pilcrow"></a>
pool._destroyPool()
  </h3>
</div>
<p>This is an internal method used by pool2 itself primarily during testing. Rejects all pending requests and destroys all open resources; disables timers and sets the pool's status to destroyed. You shouldn't need to call this, but I'm documenting it here anyway.</p>
<div class="pilwrap" id="clustering">
  <h2>
    <a href="#clustering" name="clustering" class="pilcrow"></a>
Clustering
  </h2>
</div>
<pre><code>var pool1 = new Pool(opts1),
    pool2 = new Pool(opts2);

var cluster = new Pool.Cluster([pool1, pool2]);

cluster.acquire(function (err, rsrc) {
    // do stuff
    cluster.release(rsrc);
});

cluster.acquire('read', function (err, rsrc) {
    // if you specify a capability, only pools tagged with that capability
    // will be used to serve the request
});

cluster.addPool(new Pool(...));
var pool = cluster.pools[0];
cluster.removePool(pool);

cluster.end(function (errs) {
    // errs is an array of errors returned from ending the pools
});
</code></pre>
<div class="pilwrap" id="constructor-options-1">
  <h2>
    <a href="#constructor-options-1" name="constructor-options-1" class="pilcrow"></a>
Constructor options
  </h2>
</div>
<p><code>Pool.Cluster</code> takes only one argument to its constructor: an array of <code>Pool</code> instances.</p>
<div class="pilwrap" id="instance-methods-1">
  <h2>
    <a href="#instance-methods-1" name="instance-methods-1" class="pilcrow"></a>
Instance methods
  </h2>
</div>
<div class="pilwrap" id="cluster.addpool">
  <h3>
    <a href="#cluster.addpool" name="cluster.addpool" class="pilcrow"></a>
cluster.addPool()
  </h3>
</div>
<p>Add a pool to the cluster.</p>
<div class="pilwrap" id="cluster.removepool">
  <h3>
    <a href="#cluster.removepool" name="cluster.removepool" class="pilcrow"></a>
cluster.removePool()
  </h3>
</div>
<p>Remove a pool from the cluster.</p>
<div class="pilwrap" id="cluster.pools">
  <h3>
    <a href="#cluster.pools" name="cluster.pools" class="pilcrow"></a>
cluster.pools
  </h3>
</div>
<p>An array of pools in the cluster.</p>
<div class="pilwrap" id="cluster.acquire-callback">
  <h3>
    <a href="#cluster.acquire-callback" name="cluster.acquire-callback" class="pilcrow"></a>
cluster.acquire(callback)
  </h3>
</div>
<p>Just like <code>pool.acquire</code>, except it draws a resource from any of the pools in the cluster. Resources are drawn from the pool with the most idle resources first; otherwise, order is undefined.</p>
<div class="pilwrap" id="cluster.acquire-capability-callback">
  <h3>
    <a href="#cluster.acquire-capability-callback" name="cluster.acquire-capability-callback" class="pilcrow"></a>
cluster.acquire('capability', callback)
  </h3>
</div>
<p>Like <code>cluster.acquire</code>, except only pools that list <code>'capability'</code> in their <code>capabilities</code> array are considered.</p>
<div class="pilwrap" id="cluster.end">
  <h3>
    <a href="#cluster.end" name="cluster.end" class="pilcrow"></a>
cluster.end()
  </h3>
</div>
<p>Calls <code>pool.end()</code> on all pools in this cluster, consolidates any errors, and calls back with them</p>
<div class="pilwrap" id="debugging">
  <h2>
    <a href="#debugging" name="debugging" class="pilcrow"></a>
Debugging
  </h2>
</div>
<p>Pool2 makes use of the <a href="https://www.npmjs.com/package/debug">debug</a> module. For a detailed look at what exactly the pool is doing, execute your program with <code>DEBUG=pool2</code> set.</p>
</div>
  </div>
</body>
</html>
