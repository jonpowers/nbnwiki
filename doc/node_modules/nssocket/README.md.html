<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/nssocket/README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#synposis">Synposis</a>
      </div>

      <div class="heading h1">
        <a href="#motivation">Motivation</a>
      </div>

      <div class="heading h1">
        <a href="#build-status">Build Status</a>
      </div>

      <div class="heading h1">
        <a href="#installation">Installation</a>
      </div>

      <div class="heading h1">
        <a href="#how-it-works">How it works</a>
      </div>

      <div class="heading h2">
        <a href="#messages">Messages</a>
      </div>

      <div class="heading h2">
        <a href="#simple-example">Simple Example</a>
      </div>

      <div class="heading h2">
        <a href="#reconnect-example">Reconnect Example</a>
      </div>

      <div class="heading h1">
        <a href="#api">API</a>
      </div>

      <div class="heading h3">
        <a href="#socket.send-event-data">socket.send(event, data)</a>
      </div>

      <div class="heading h3">
        <a href="#socket.on-event-callback">socket.on(event, callback)</a>
      </div>

      <div class="heading h3">
        <a href="#socket.data-event-callback">socket.data(event, callback)</a>
      </div>

      <div class="heading h3">
        <a href="#socket.end">socket.end()</a>
      </div>

      <div class="heading h3">
        <a href="#socket.destroy">socket.destroy()</a>
      </div>

      <div class="heading h2">
        <a href="#tests">Tests</a>
      </div>

      <div class="heading h3">
        <a href="#author-nodejitsu">Author: Nodejitsu</a>
      </div>

      <div class="heading h3">
        <a href="#contributors-paolo-fragomeni-charlie-robbins-jameson-lee-gene-diaz-jr">Contributors: Paolo Fragomeni, Charlie Robbins, Jameson Lee, Gene Diaz Jr.</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><div class="pilwrap" id="synposis">
  <h1>
    <a href="#synposis" name="synposis" class="pilcrow"></a>
Synposis
  </h1>
</div>
<p>An elegant way to define lightweight protocols on-top of TCP/TLS sockets in node.js</p>
<div class="pilwrap" id="motivation">
  <h1>
    <a href="#motivation" name="motivation" class="pilcrow"></a>
Motivation
  </h1>
</div>
<p>Working within node.js it is very easy to write lightweight network protocols that communicate over TCP or TLS. The definition of such protocols often requires repeated (and tedious) parsing of individual TCP/TLS packets into a message header and some JSON body.</p>
<div class="pilwrap" id="build-status">
  <h1>
    <a href="#build-status" name="build-status" class="pilcrow"></a>
Build Status
  </h1>
</div>
<p><a href="http://travis-ci.org/nodejitsu/nssocket"><img src="https://secure.travis-ci.org/nodejitsu/nssocket.png" alt="Build Status"></a></p>
<div class="pilwrap" id="installation">
  <h1>
    <a href="#installation" name="installation" class="pilcrow"></a>
Installation
  </h1>
</div>
<pre><code>  [sudo] npm install nssocket
</code></pre>
<div class="pilwrap" id="how-it-works">
  <h1>
    <a href="#how-it-works" name="how-it-works" class="pilcrow"></a>
How it works
  </h1>
</div>
<p>With <code>nssocket</code> this tedious bookkeeping work is done automatically for you in two ways:</p>
<ol>
<li>Leverages wildcard and namespaced events from <a href="http://github.com/hij1nx/eventemitter2">EventEmitter2</a></li>
<li>Automatically serializes messages passed to <code>.send()</code> and deserializes messages from <code>data</code> events.</li>
<li>Implements default reconnect logic for potentially faulty connections.</li>
<li>Automatically wraps TCP connections with TLS using <a href="https://gist.github.com/848444">a known workaround</a></li>
</ol>
<div class="pilwrap" id="messages">
  <h2>
    <a href="#messages" name="messages" class="pilcrow"></a>
Messages
  </h2>
</div>
<p>Messages in <code>nssocket</code> are serialized JSON arrays of the following form:</p>
<pre><code class="js">  [<span class="hljs-string">"namespace"</span>, <span class="hljs-string">"to"</span>, <span class="hljs-string">"event"</span>, { <span class="hljs-string">"this"</span>: <span class="hljs-string">"is"</span>, <span class="hljs-string">"the"</span>: <span class="hljs-string">"payload"</span> }]
</code></pre>
<p>Although this is not as optimal as other message formats (pure binary, msgpack) most of your applications are probably IO-bound, and not by the computation time needed for serialization / deserialization. When working with <code>NsSocket</code> instances, all events are namespaced under <code>data</code> to avoid collision with other events.</p>
<div class="pilwrap" id="simple-example">
  <h2>
    <a href="#simple-example" name="simple-example" class="pilcrow"></a>
Simple Example
  </h2>
</div>
<pre><code class="js">  <span class="hljs-keyword">var</span> nssocket = <span class="hljs-built_in">require</span>(<span class="hljs-string">'nssocket'</span>);

  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// Create an `nssocket` TCP server</span>
  <span class="hljs-comment">//</span>
  <span class="hljs-keyword">var</span> server = nssocket.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">socket</span>) </span>{
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Here `socket` will be an instance of `nssocket.NsSocket`.</span>
    <span class="hljs-comment">//</span>
    socket.send([<span class="hljs-string">'you'</span>, <span class="hljs-string">'there'</span>]);
    socket.data([<span class="hljs-string">'iam'</span>, <span class="hljs-string">'here'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
      <span class="hljs-comment">//</span>
      <span class="hljs-comment">// Good! The socket speaks our language </span>
      <span class="hljs-comment">// (i.e. simple 'you::there', 'iam::here' protocol)</span>
      <span class="hljs-comment">//</span>
      <span class="hljs-comment">// { iam: true, indeedHere: true }</span>
      <span class="hljs-comment">//</span>
      <span class="hljs-built_in">console</span>.dir(data);
    })
  });
  
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// Tell the server to listen on port `6785` and then connect to it</span>
  <span class="hljs-comment">// using another NsSocket instance.</span>
  <span class="hljs-comment">//</span>
  server.listen(<span class="hljs-number">6785</span>);
  
  <span class="hljs-keyword">var</span> outbound = <span class="hljs-keyword">new</span> nssocket.NsSocket();
  outbound.data([<span class="hljs-string">'you'</span>, <span class="hljs-string">'there'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    outbound.send([<span class="hljs-string">'iam'</span>, <span class="hljs-string">'here'</span>], { <span class="hljs-attr">iam</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">indeedHere</span>: <span class="hljs-literal">true</span> });
  });
  
  outbound.connect(<span class="hljs-number">6785</span>);
</code></pre>
<div class="pilwrap" id="reconnect-example">
  <h2>
    <a href="#reconnect-example" name="reconnect-example" class="pilcrow"></a>
Reconnect Example
  </h2>
</div>
<p><code>nssocket</code> exposes simple options for enabling reconnection of the underlying socket. By default, these options are disabled. Lets look at a simple example:</p>
<pre><code class="js">  <span class="hljs-keyword">var</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>),
      nssocket = <span class="hljs-built_in">require</span>(<span class="hljs-string">'nssocket'</span>);
  
  net.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">socket</span>) </span>{
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Close the underlying socket after `1000ms`</span>
    <span class="hljs-comment">//</span>
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      socket.destroy();
    }, <span class="hljs-number">1000</span>);
  }).listen(<span class="hljs-number">8345</span>);
  
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// Create an NsSocket instance with reconnect enabled</span>
  <span class="hljs-comment">//</span>
  <span class="hljs-keyword">var</span> socket = <span class="hljs-keyword">new</span> nssocket.NsSocket({
    <span class="hljs-attr">reconnect</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'tcp4'</span>,
  });
  
  socket.on(<span class="hljs-string">'start'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// The socket will emit this event periodically</span>
    <span class="hljs-comment">// as it attempts to reconnect</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-built_in">console</span>.dir(<span class="hljs-string">'start'</span>);
  });
  
  socket.connect(<span class="hljs-number">8345</span>);
</code></pre>
<div class="pilwrap" id="api">
  <h1>
    <a href="#api" name="api" class="pilcrow"></a>
API
  </h1>
</div>
<div class="pilwrap" id="socket.send-event-data">
  <h3>
    <a href="#socket.send-event-data" name="socket.send-event-data" class="pilcrow"></a>
socket.send(event, data)
  </h3>
</div>
<p>Writes <code>data</code> to the socket with the specified <code>event</code>, on the receiving end it will look like: <code>JSON.stringify([event, data])</code>.</p>
<div class="pilwrap" id="socket.on-event-callback">
  <h3>
    <a href="#socket.on-event-callback" name="socket.on-event-callback" class="pilcrow"></a>
socket.on(event, callback)
  </h3>
</div>
<p>Equivalent to the underlying <code>.addListener()</code> or <code>.on()</code> function on the underlying socket except that it will permit all <code>EventEmitter2</code> wildcards and namespaces.</p>
<div class="pilwrap" id="socket.data-event-callback">
  <h3>
    <a href="#socket.data-event-callback" name="socket.data-event-callback" class="pilcrow"></a>
socket.data(event, callback)
  </h3>
</div>
<p>Helper function for performing shorthand listeners namespaced under the <code>data</code> event. For example:</p>
<pre><code class="js">  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// These two statements are equivalent</span>
  <span class="hljs-comment">//</span>
  someSocket.on([<span class="hljs-string">'data'</span>, <span class="hljs-string">'some'</span>, <span class="hljs-string">'event'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{ });
  someSocket.data([<span class="hljs-string">'some'</span>, <span class="hljs-string">'event'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{ });
</code></pre>
<div class="pilwrap" id="socket.end">
  <h3>
    <a href="#socket.end" name="socket.end" class="pilcrow"></a>
socket.end()
  </h3>
</div>
<p>Closes the current socket, emits <code>close</code> event, possibly also <code>error</code></p>
<div class="pilwrap" id="socket.destroy">
  <h3>
    <a href="#socket.destroy" name="socket.destroy" class="pilcrow"></a>
socket.destroy()
  </h3>
</div>
<p>Remove all listeners, destroys socket, clears buffer. It is recommended that you use <code>socket.end()</code>.</p>
<div class="pilwrap" id="tests">
  <h2>
    <a href="#tests" name="tests" class="pilcrow"></a>
Tests
  </h2>
</div>
<p>All tests are written with <a href="http://vowsjs.org">vows</a> and should be run through <a href="http://npmjs.org">npm</a>:</p>
<pre><code class="bash">  $ npm <span class="hljs-built_in">test</span>
</code></pre>
<div class="pilwrap" id="author-nodejitsu">
  <h3>
    <a href="#author-nodejitsu" name="author-nodejitsu" class="pilcrow"></a>
Author: <a href="http://www.nodejitsu.com">Nodejitsu</a>
  </h3>
</div>
<div class="pilwrap" id="contributors-paolo-fragomeni-charlie-robbins-jameson-lee-gene-diaz-jr">
  <h3>
    <a href="#contributors-paolo-fragomeni-charlie-robbins-jameson-lee-gene-diaz-jr" name="contributors-paolo-fragomeni-charlie-robbins-jameson-lee-gene-diaz-jr" class="pilcrow"></a>
Contributors: <a href="http://github.com/hij1nx">Paolo Fragomeni</a>, <a href="http://github.com/indexzero">Charlie Robbins</a>, <a href="http://github.com/drjackal">Jameson Lee</a>, <a href="http://github.com/genediazjr">Gene Diaz Jr.</a>
  </h3>
</div>
</div>
  </div>
</body>
</html>
