<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/continuation-local-storage/README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#continuation-local-storage">Continuation-Local Storage</a>
      </div>

      <div class="heading h2">
        <a href="#cls.createnamespace-name">cls.createNamespace(name)</a>
      </div>

      <div class="heading h2">
        <a href="#cls.getnamespace-name">cls.getNamespace(name)</a>
      </div>

      <div class="heading h2">
        <a href="#cls.destroynamespace-name">cls.destroyNamespace(name)</a>
      </div>

      <div class="heading h2">
        <a href="#cls.reset">cls.reset()</a>
      </div>

      <div class="heading h2">
        <a href="#process.namespaces">process.namespaces</a>
      </div>

      <div class="heading h2">
        <a href="#class-namespace">Class: Namespace</a>
      </div>

      <div class="heading h3">
        <a href="#namespace.active">namespace.active</a>
      </div>

      <div class="heading h3">
        <a href="#namespace.set-key-value">namespace.set(key, value)</a>
      </div>

      <div class="heading h3">
        <a href="#namespace.get-key">namespace.get(key)</a>
      </div>

      <div class="heading h3">
        <a href="#namespace.run-callback">namespace.run(callback)</a>
      </div>

      <div class="heading h3">
        <a href="#namespace.runandreturn-callback">namespace.runAndReturn(callback)</a>
      </div>

      <div class="heading h3">
        <a href="#namespace.bind-callback-context">namespace.bind(callback, [context])</a>
      </div>

      <div class="heading h3">
        <a href="#namespace.bindemitter-emitter">namespace.bindEmitter(emitter)</a>
      </div>

      <div class="heading h3">
        <a href="#namespace.createcontext">namespace.createContext()</a>
      </div>

      <div class="heading h2">
        <a href="#context">context</a>
      </div>

      <div class="heading h1">
        <a href="#copyright-and-license">copyright &amp;amp; license</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><p><a href="https://nodei.co/npm/continuation-local-storage/"><img src="https://nodei.co/npm/continuation-local-storage.png?downloads=true&amp;stars=true" alt="NPM"></a></p>
<div class="pilwrap" id="continuation-local-storage">
  <h1>
    <a href="#continuation-local-storage" name="continuation-local-storage" class="pilcrow"></a>
Continuation-Local Storage
  </h1>
</div>
<p>Continuation-local storage works like thread-local storage in threaded
programming, but is based on chains of Node-style callbacks instead of threads.
The standard Node convention of functions calling functions is very similar to
something called <a href="http://en.wikipedia.org/wiki/Continuation-passing_style">&quot;continuation-passing style&quot;</a> in functional programming,
and the name comes from the way this module allows you to set and get values
that are scoped to the lifetime of these chains of function calls.</p>
<p>Suppose you're writing a module that fetches a user and adds it to a session
before calling a function passed in by a user to continue execution:</p>
<pre><code class="javascript"><span class="hljs-comment">// setup.js</span>

<span class="hljs-keyword">var</span> createNamespace = <span class="hljs-built_in">require</span>(<span class="hljs-string">'continuation-local-storage'</span>).createNamespace;
<span class="hljs-keyword">var</span> session = createNamespace(<span class="hljs-string">'my session'</span>);

<span class="hljs-keyword">var</span> db = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./lib/db.js'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">start</span>(<span class="hljs-params">options, next</span>) </span>{
  db.fetchUserById(options.id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, user</span>) </span>{
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> next(error);

    session.set(<span class="hljs-string">'user'</span>, user);

    next();
  });
}
</code></pre>
<p>Later on in the process of turning that user's data into an HTML page, you call
another function (maybe defined in another module entirely) that wants to fetch
the value you set earlier:</p>
<pre><code class="javascript"><span class="hljs-comment">// send_response.js</span>

<span class="hljs-keyword">var</span> getNamespace = <span class="hljs-built_in">require</span>(<span class="hljs-string">'continuation-local-storage'</span>).getNamespace;
<span class="hljs-keyword">var</span> session = getNamespace(<span class="hljs-string">'my session'</span>);

<span class="hljs-keyword">var</span> render = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./lib/render.js'</span>)

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">finish</span>(<span class="hljs-params">response</span>) </span>{
  <span class="hljs-keyword">var</span> user = session.get(<span class="hljs-string">'user'</span>);
  render({<span class="hljs-attr">user</span>: user}).pipe(response);
}
</code></pre>
<p>When you set values in continuation-local storage, those values are accessible
until all functions called from the original function – synchronously or
asynchronously – have finished executing. This includes callbacks passed to
<code>process.nextTick</code> and the <a href="https://nodejs.org/api/timers.html">timer functions</a> (<a href="https://nodejs.org/api/timers.html#timers_setimmediate_callback_arg">setImmediate</a>,
<a href="https://nodejs.org/api/timers.html#timers_settimeout_callback_delay_arg">setTimeout</a>, and <a href="https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_arg">setInterval</a>), as well as callbacks passed to
asynchronous functions that call native functions (such as those exported from
the <code>fs</code>, <code>dns</code>, <code>zlib</code> and <code>crypto</code> modules).</p>
<p>A simple rule of thumb is anywhere where you might have set a property on the
<code>request</code> or <code>response</code> objects in an HTTP handler, you can (and should) now
use continuation-local storage. This API is designed to allow you extend the
scope of a variable across a sequence of function calls, but with values
specific to each sequence of calls.</p>
<p>Values are grouped into namespaces, created with <code>createNamespace()</code>. Sets of
function calls are grouped together by calling them within the function passed
to <code>.run()</code> on the namespace object. Calls to <code>.run()</code> can be nested, and each
nested context this creates has its own copy of the set of values from the
parent context. When a function is making multiple asynchronous calls, this
allows each child call to get, set, and pass along its own context without
overwriting the parent's.</p>
<p>A simple, annotated example of how this nesting behaves:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> createNamespace = <span class="hljs-built_in">require</span>(<span class="hljs-string">'continuation-local-storage'</span>).createNamespace;

<span class="hljs-keyword">var</span> writer = createNamespace(<span class="hljs-string">'writer'</span>);
writer.run(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  writer.set(<span class="hljs-string">'value'</span>, <span class="hljs-number">0</span>);

  requestHandler();
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestHandler</span>(<span class="hljs-params"></span>) </span>{
  writer.run(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">outer</span>) </span>{
    <span class="hljs-comment">// writer.get('value') returns 0</span>
    <span class="hljs-comment">// outer.value is 0</span>
    writer.set(<span class="hljs-string">'value'</span>, <span class="hljs-number">1</span>);
    <span class="hljs-comment">// writer.get('value') returns 1</span>
    <span class="hljs-comment">// outer.value is 1</span>
    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-comment">// writer.get('value') returns 1</span>
      <span class="hljs-comment">// outer.value is 1</span>
      writer.run(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">inner</span>) </span>{
        <span class="hljs-comment">// writer.get('value') returns 1</span>
        <span class="hljs-comment">// outer.value is 1</span>
        <span class="hljs-comment">// inner.value is 1</span>
        writer.set(<span class="hljs-string">'value'</span>, <span class="hljs-number">2</span>);
        <span class="hljs-comment">// writer.get('value') returns 2</span>
        <span class="hljs-comment">// outer.value is 1</span>
        <span class="hljs-comment">// inner.value is 2</span>
      });
    });
  });

  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// runs with the default context, because nested contexts have ended</span>
    <span class="hljs-built_in">console</span>.log(writer.get(<span class="hljs-string">'value'</span>)); <span class="hljs-comment">// prints 0</span>
  }, <span class="hljs-number">1000</span>);
}
</code></pre>
<div class="pilwrap" id="cls.createnamespace-name">
  <h2>
    <a href="#cls.createnamespace-name" name="cls.createnamespace-name" class="pilcrow"></a>
cls.createNamespace(name)
  </h2>
</div>
<ul>
<li>return: {Namespace}</li>
</ul>
<p>Each application wanting to use continuation-local values should create its own
namespace. Reading from (or, more significantly, writing to) namespaces that
don't belong to you is a faux pas.</p>
<div class="pilwrap" id="cls.getnamespace-name">
  <h2>
    <a href="#cls.getnamespace-name" name="cls.getnamespace-name" class="pilcrow"></a>
cls.getNamespace(name)
  </h2>
</div>
<ul>
<li>return: {Namespace}</li>
</ul>
<p>Look up an existing namespace.</p>
<div class="pilwrap" id="cls.destroynamespace-name">
  <h2>
    <a href="#cls.destroynamespace-name" name="cls.destroynamespace-name" class="pilcrow"></a>
cls.destroyNamespace(name)
  </h2>
</div>
<p>Dispose of an existing namespace. WARNING: be sure to dispose of any references
to destroyed namespaces in your old code, as contexts associated with them will
no longer be propagated.</p>
<div class="pilwrap" id="cls.reset">
  <h2>
    <a href="#cls.reset" name="cls.reset" class="pilcrow"></a>
cls.reset()
  </h2>
</div>
<p>Completely reset all continuation-local storage namespaces. WARNING: while this
will stop the propagation of values in any existing namespaces, if there are
remaining references to those namespaces in code, the associated storage will
still be reachable, even though the associated state is no longer being updated.
Make sure you clean up any references to destroyed namespaces yourself.</p>
<div class="pilwrap" id="process.namespaces">
  <h2>
    <a href="#process.namespaces" name="process.namespaces" class="pilcrow"></a>
process.namespaces
  </h2>
</div>
<ul>
<li>return: dictionary of {Namespace} objects</li>
</ul>
<p>Continuation-local storage has a performance cost, and so it isn't enabled
until the module is loaded for the first time. Once the module is loaded, the
current set of namespaces is available in <code>process.namespaces</code>, so library code
that wants to use continuation-local storage only when it's active should test
for the existence of <code>process.namespaces</code>.</p>
<div class="pilwrap" id="class-namespace">
  <h2>
    <a href="#class-namespace" name="class-namespace" class="pilcrow"></a>
Class: Namespace
  </h2>
</div>
<p>Application-specific namespaces group values local to the set of functions
whose calls originate from a callback passed to <code>namespace.run()</code> or
<code>namespace.bind()</code>.</p>
<div class="pilwrap" id="namespace.active">
  <h3>
    <a href="#namespace.active" name="namespace.active" class="pilcrow"></a>
namespace.active
  </h3>
</div>
<ul>
<li>return: the currently active context on a namespace</li>
</ul>
<div class="pilwrap" id="namespace.set-key-value">
  <h3>
    <a href="#namespace.set-key-value" name="namespace.set-key-value" class="pilcrow"></a>
namespace.set(key, value)
  </h3>
</div>
<ul>
<li>return: <code>value</code></li>
</ul>
<p>Set a value on the current continuation context. Must be set within an active
continuation chain started with <code>namespace.run()</code> or <code>namespace.bind()</code>.</p>
<div class="pilwrap" id="namespace.get-key">
  <h3>
    <a href="#namespace.get-key" name="namespace.get-key" class="pilcrow"></a>
namespace.get(key)
  </h3>
</div>
<ul>
<li>return: the requested value, or <code>undefined</code></li>
</ul>
<p>Look up a value on the current continuation context. Recursively searches from
the innermost to outermost nested continuation context for a value associated
with a given key. Must be set within an active continuation chain started with
<code>namespace.run()</code> or <code>namespace.bind()</code>.</p>
<div class="pilwrap" id="namespace.run-callback">
  <h3>
    <a href="#namespace.run-callback" name="namespace.run-callback" class="pilcrow"></a>
namespace.run(callback)
  </h3>
</div>
<ul>
<li>return: the context associated with that callback</li>
</ul>
<p>Create a new context on which values can be set or read. Run all the functions
that are called (either directly, or indirectly through asynchronous functions
that take callbacks themselves) from the provided callback within the scope of
that namespace. The new context is passed as an argument to the callback
when it's called.</p>
<div class="pilwrap" id="namespace.runandreturn-callback">
  <h3>
    <a href="#namespace.runandreturn-callback" name="namespace.runandreturn-callback" class="pilcrow"></a>
namespace.runAndReturn(callback)
  </h3>
</div>
<ul>
<li>return: the return value of the callback</li>
</ul>
<p>Create a new context on which values can be set or read. Run all the functions
that are called (either directly, or indirectly through asynchronous functions
that take callbacks themselves) from the provided callback within the scope of
that namespace. The new context is passed as an argument to the callback
when it's called.</p>
<p>Same as <code>namespace.run()</code> but returns the return value of the callback rather
than the context.</p>
<div class="pilwrap" id="namespace.bind-callback-context">
  <h3>
    <a href="#namespace.bind-callback-context" name="namespace.bind-callback-context" class="pilcrow"></a>
namespace.bind(callback, [context])
  </h3>
</div>
<ul>
<li>return: a callback wrapped up in a context closure</li>
</ul>
<p>Bind a function to the specified namespace. Works analogously to
<code>Function.bind()</code> or <code>domain.bind()</code>. If context is omitted, it will default to
the currently active context in the namespace, or create a new context if none
is currently defined.</p>
<div class="pilwrap" id="namespace.bindemitter-emitter">
  <h3>
    <a href="#namespace.bindemitter-emitter" name="namespace.bindemitter-emitter" class="pilcrow"></a>
namespace.bindEmitter(emitter)
  </h3>
</div>
<p>Bind an EventEmitter to a namespace. Operates similarly to <code>domain.add</code>, with a
less generic name and the additional caveat that unlike domains, namespaces
never implicitly bind EventEmitters to themselves when they're created within
the context of an active namespace.</p>
<p>The most likely time you'd want to use this is when you're using Express or
Connect and want to make sure your middleware execution plays nice with CLS, or
are doing other things with HTTP listeners:</p>
<pre><code class="javascript">http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>{
  writer.bindEmitter(req);
  writer.bindEmitter(res);

  <span class="hljs-comment">// do other stuff, some of which is asynchronous</span>
});
</code></pre>
<div class="pilwrap" id="namespace.createcontext">
  <h3>
    <a href="#namespace.createcontext" name="namespace.createcontext" class="pilcrow"></a>
namespace.createContext()
  </h3>
</div>
<ul>
<li>return: a context cloned from the currently active context</li>
</ul>
<p>Use this with <code>namespace.bind()</code>, if you want to have a fresh context at invocation time,
as opposed to binding time:</p>
<pre><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params">p</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"%s = %s"</span>, p, ns.get(p));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bindLater</span>(<span class="hljs-params">callback</span>) </span>{
  <span class="hljs-keyword">return</span> writer.bind(callback, writer.createContext());
}

setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> bound = bindLater(doSomething);
  bound(<span class="hljs-string">'test'</span>);
}, <span class="hljs-number">100</span>);
</code></pre>
<div class="pilwrap" id="context">
  <h2>
    <a href="#context" name="context" class="pilcrow"></a>
context
  </h2>
</div>
<p>A context is a plain object created using the enclosing context as its prototype.</p>
<div class="pilwrap" id="copyright-and-license">
  <h1>
    <a href="#copyright-and-license" name="copyright-and-license" class="pilcrow"></a>
copyright &amp; license
  </h1>
</div>
<p>See <a href="https://github.com/othiym23/node-continuation-local-storage/blob/master/LICENSE">LICENSE</a>
for the details of the BSD 2-clause &quot;simplified&quot; license used by
<code>continuation-local-storage</code>. This package was developed in 2012-2013 (and is
maintained now) by Forrest L Norvell, <a href="https://github.com/othiym23">@othiym23</a>,
with considerable help from Timothy Caswell,
<a href="https://github.com/creationix">@creationix</a>, working for The Node Firm. This
work was underwritten by New Relic for use in their Node.js instrumentation
agent, so maybe give that a look if you have some Node.js
performance-monitoring needs.</p>
</div>
  </div>
</body>
</html>
