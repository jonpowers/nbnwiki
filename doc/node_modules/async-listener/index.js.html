<!DOCTYPE html>
<html>
<head>
  <title>index.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/async-listener/index.js";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>index.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">if</span> (process.addAsyncListener) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Don't require polyfill unless needed"</span>);

<span class="hljs-keyword">var</span> shimmer      = <span class="hljs-built_in">require</span>(<span class="hljs-string">'shimmer'</span>)
  , semver       = <span class="hljs-built_in">require</span>(<span class="hljs-string">'semver'</span>)
  , wrap         = shimmer.wrap
  , massWrap     = shimmer.massWrap
  , wrapCallback = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./glue.js'</span>)
  , util         = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>)
  ;

<span class="hljs-keyword">var</span> v7plus = semver.gte(process.version, <span class="hljs-string">'7.0.0'</span>);

<span class="hljs-keyword">var</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>From Node.js v7.0.0, net._normalizeConnectArgs have been renamed net._normalizeConnectArgs</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">if</span> (v7plus &amp;&amp; !net._normalizeArgs) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>a polyfill in our polyfill etc so forth -- taken from node master on 2017/03/09</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  net._normalizeArgs = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) </span>{
    <span class="hljs-keyword">if</span> (args.length === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> [{}, <span class="hljs-literal">null</span>];
    }

    <span class="hljs-keyword">var</span> arg0 = args[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">var</span> options = {};
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> arg0 === <span class="hljs-string">'object'</span> &amp;&amp; arg0 !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>(options[...][, cb])</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      options = arg0;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isPipeName(arg0)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>(path[...][, cb])</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      options.path = arg0;
    } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>([port][, host][...][, cb])</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      options.port = arg0;
      <span class="hljs-keyword">if</span> (args.length &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-keyword">typeof</span> args[<span class="hljs-number">1</span>] === <span class="hljs-string">'string'</span>) {
        options.host = args[<span class="hljs-number">1</span>];
      }
    }

    <span class="hljs-keyword">var</span> cb = args[args.length - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cb !== <span class="hljs-string">'function'</span>)
      <span class="hljs-keyword">return</span> [options, <span class="hljs-literal">null</span>];
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">return</span> [options, cb];
  }
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!v7plus &amp;&amp; !net._normalizeConnectArgs) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>a polyfill in our polyfill etc so forth -- taken from node master on 2013/10/30</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  net._normalizeConnectArgs = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) </span>{
    <span class="hljs-keyword">var</span> options = {};

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toNumber</span>(<span class="hljs-params">x</span>) </span>{ <span class="hljs-keyword">return</span> (x = <span class="hljs-built_in">Number</span>(x)) &gt;= <span class="hljs-number">0</span> ? x : <span class="hljs-literal">false</span>; }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args[<span class="hljs-number">0</span>] === <span class="hljs-string">'object'</span> &amp;&amp; args[<span class="hljs-number">0</span>] !== <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>connect(options, [cb])</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      options = args[<span class="hljs-number">0</span>];
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args[<span class="hljs-number">0</span>] === <span class="hljs-string">'string'</span> &amp;&amp; toNumber(args[<span class="hljs-number">0</span>]) === <span class="hljs-literal">false</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>connect(path, [cb]);</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      options.path = args[<span class="hljs-number">0</span>];
    }
    <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>connect(port, [host], [cb])</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      options.port = args[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args[<span class="hljs-number">1</span>] === <span class="hljs-string">'string'</span>) {
        options.host = args[<span class="hljs-number">1</span>];
      }
    }

    <span class="hljs-keyword">var</span> cb = args[args.length - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> cb === <span class="hljs-string">'function'</span> ? [options, cb] : [options];
  };
}

wrap(net.Server.prototype, <span class="hljs-string">'_listen2'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">original</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'connection'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">socket</span>) </span>{
      <span class="hljs-keyword">if</span> (socket._handle) {
        socket._handle.onread = wrapCallback(socket._handle.onread);
      }
    });

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> original.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }
    <span class="hljs-keyword">finally</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>the handle will only not be set in cases where there has been an error</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._handle &amp;&amp; <span class="hljs-keyword">this</span>._handle.onconnection) {
        <span class="hljs-keyword">this</span>._handle.onconnection = wrapCallback(<span class="hljs-keyword">this</span>._handle.onconnection);
      }
    }
  };
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">patchOnRead</span>(<span class="hljs-params">ctx</span>) </span>{
  <span class="hljs-keyword">if</span> (ctx &amp;&amp; ctx._handle) {
    <span class="hljs-keyword">var</span> handle = ctx._handle;
    <span class="hljs-keyword">if</span> (!handle._originalOnread) {
      handle._originalOnread = handle.onread;
    }
    handle.onread = wrapCallback(handle._originalOnread);
  }
}

wrap(net.Socket.prototype, <span class="hljs-string">'connect'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">original</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>From Node.js v7.0.0, net._normalizeConnectArgs have been renamed net._normalizeConnectArgs</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> args = v7plus
      ? net._normalizeArgs(<span class="hljs-built_in">arguments</span>)
      : net._normalizeConnectArgs(<span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">if</span> (args[<span class="hljs-number">1</span>]) args[<span class="hljs-number">1</span>] = wrapCallback(args[<span class="hljs-number">1</span>]);
    <span class="hljs-keyword">var</span> result = original.apply(<span class="hljs-keyword">this</span>, args);
    patchOnRead(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> result;
  };
});

<span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>NOTE: A rewrite occurred in 0.11 that changed the addRequest signature
from (req, host, port, localAddress) to (req, options)
Here, I use the longer signature to maintain 0.10 support, even though
the rest of the arguments aren't actually used</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">wrap(http.Agent.prototype, <span class="hljs-string">'addRequest'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">original</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req</span>) </span>{
    <span class="hljs-keyword">var</span> onSocket = req.onSocket;
    req.onSocket = wrapCallback(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">socket</span>) </span>{
      patchOnRead(socket);
      <span class="hljs-keyword">return</span> onSocket.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    });
    <span class="hljs-keyword">return</span> original.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
  };
});

<span class="hljs-keyword">var</span> childProcess = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapChildProcess</span>(<span class="hljs-params">child</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(child.stdio)) {
    child.stdio.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">socket</span>) </span>{
      <span class="hljs-keyword">if</span> (socket &amp;&amp; socket._handle) {
        socket._handle.onread = wrapCallback(socket._handle.onread);
        wrap(socket._handle, <span class="hljs-string">'close'</span>, activatorFirst);
      }
    });
  }

  <span class="hljs-keyword">if</span> (child._handle) {
    child._handle.onexit = wrapCallback(child._handle.onexit);
  }
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>iojs v2.0.0+</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">if</span> (childProcess.ChildProcess) {
  wrap(childProcess.ChildProcess.prototype, <span class="hljs-string">'spawn'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">original</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> result = original.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
      wrapChildProcess(<span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">return</span> result;
    };
  });
} <span class="hljs-keyword">else</span> {
  massWrap(childProcess, [
    <span class="hljs-string">'execFile'</span>, <span class="hljs-comment">// exec is implemented in terms of execFile</span>
    <span class="hljs-string">'fork'</span>,
    <span class="hljs-string">'spawn'</span>
  ], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">original</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> result = original.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
      wrapChildProcess(result);
      <span class="hljs-keyword">return</span> result;
    };
  });
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>need unwrapped nextTick for use within &lt; 0.9 async error handling</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">if</span> (!process._fatalException) {
  process._originalNextTick = process.nextTick;
}

<span class="hljs-keyword">var</span> processors = [];
<span class="hljs-keyword">if</span> (process._nextDomainTick) processors.push(<span class="hljs-string">'_nextDomainTick'</span>);
<span class="hljs-keyword">if</span> (process._tickDomainCallback) processors.push(<span class="hljs-string">'_tickDomainCallback'</span>);

massWrap(
  process,
  processors,
  activator
);
wrap(process, <span class="hljs-string">'nextTick'</span>, activatorFirst);

<span class="hljs-keyword">var</span> asynchronizers = [
  <span class="hljs-string">'setTimeout'</span>,
  <span class="hljs-string">'setInterval'</span>
];
<span class="hljs-keyword">if</span> (global.setImmediate) asynchronizers.push(<span class="hljs-string">'setImmediate'</span>);

<span class="hljs-keyword">var</span> timers = <span class="hljs-built_in">require</span>(<span class="hljs-string">'timers'</span>);
<span class="hljs-keyword">var</span> patchGlobalTimers = global.setTimeout === timers.setTimeout;

massWrap(
  timers,
  asynchronizers,
  activatorFirst
);

<span class="hljs-keyword">if</span> (patchGlobalTimers) {
  massWrap(
    global,
    asynchronizers,
    activatorFirst
  );
}

<span class="hljs-keyword">var</span> dns = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dns'</span>);
massWrap(
  dns,
  [
    <span class="hljs-string">'lookup'</span>,
    <span class="hljs-string">'resolve'</span>,
    <span class="hljs-string">'resolve4'</span>,
    <span class="hljs-string">'resolve6'</span>,
    <span class="hljs-string">'resolveCname'</span>,
    <span class="hljs-string">'resolveMx'</span>,
    <span class="hljs-string">'resolveNs'</span>,
    <span class="hljs-string">'resolveTxt'</span>,
    <span class="hljs-string">'resolveSrv'</span>,
    <span class="hljs-string">'reverse'</span>
  ],
  activator
);

<span class="hljs-keyword">if</span> (dns.resolveNaptr) wrap(dns, <span class="hljs-string">'resolveNaptr'</span>, activator);

<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
massWrap(
  fs,
  [
    <span class="hljs-string">'watch'</span>,
    <span class="hljs-string">'rename'</span>,
    <span class="hljs-string">'truncate'</span>,
    <span class="hljs-string">'chown'</span>,
    <span class="hljs-string">'fchown'</span>,
    <span class="hljs-string">'chmod'</span>,
    <span class="hljs-string">'fchmod'</span>,
    <span class="hljs-string">'stat'</span>,
    <span class="hljs-string">'lstat'</span>,
    <span class="hljs-string">'fstat'</span>,
    <span class="hljs-string">'link'</span>,
    <span class="hljs-string">'symlink'</span>,
    <span class="hljs-string">'readlink'</span>,
    <span class="hljs-string">'realpath'</span>,
    <span class="hljs-string">'unlink'</span>,
    <span class="hljs-string">'rmdir'</span>,
    <span class="hljs-string">'mkdir'</span>,
    <span class="hljs-string">'readdir'</span>,
    <span class="hljs-string">'close'</span>,
    <span class="hljs-string">'open'</span>,
    <span class="hljs-string">'utimes'</span>,
    <span class="hljs-string">'futimes'</span>,
    <span class="hljs-string">'fsync'</span>,
    <span class="hljs-string">'write'</span>,
    <span class="hljs-string">'read'</span>,
    <span class="hljs-string">'readFile'</span>,
    <span class="hljs-string">'writeFile'</span>,
    <span class="hljs-string">'appendFile'</span>,
    <span class="hljs-string">'watchFile'</span>,
    <span class="hljs-string">'unwatchFile'</span>,
    <span class="hljs-string">"exists"</span>,
  ],
  activator
);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>only wrap lchown and lchmod on systems that have them.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">if</span> (fs.lchown) wrap(fs, <span class="hljs-string">'lchown'</span>, activator);
<span class="hljs-keyword">if</span> (fs.lchmod) wrap(fs, <span class="hljs-string">'lchmod'</span>, activator);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>only wrap ftruncate in versions of node that have it</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">if</span> (fs.ftruncate) wrap(fs, <span class="hljs-string">'ftruncate'</span>, activator);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>Wrap zlib streams</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> zlib;
<span class="hljs-keyword">try</span> { zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">'zlib'</span>); } <span class="hljs-keyword">catch</span> (err) { }
<span class="hljs-keyword">if</span> (zlib &amp;&amp; zlib.Deflate &amp;&amp; zlib.Deflate.prototype) {
  <span class="hljs-keyword">var</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(zlib.Deflate.prototype);
  <span class="hljs-keyword">if</span> (proto._transform) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<p>streams2</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    wrap(proto, <span class="hljs-string">"_transform"</span>, activator);
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (proto.write &amp;&amp; proto.flush &amp;&amp; proto.end) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>plain ol' streams</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    massWrap(
      proto,
      [
        <span class="hljs-string">'write'</span>,
        <span class="hljs-string">'flush'</span>,
        <span class="hljs-string">'end'</span>
      ],
      activator
    );
  }
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<p>Wrap Crypto</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> crypto;
<span class="hljs-keyword">try</span> { crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>); } <span class="hljs-keyword">catch</span> (err) { }
<span class="hljs-keyword">if</span> (crypto) {
  massWrap(
    crypto,
    [
      <span class="hljs-string">'pbkdf2'</span>,
      <span class="hljs-string">'randomBytes'</span>,
      <span class="hljs-string">'pseudoRandomBytes'</span>,
    ],
    activator
  );
}

<span class="hljs-keyword">var</span> instrumentPromise = !!global.Promise;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>Check that global Promise is native</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">if</span> (instrumentPromise) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<p>shoult not use any methods that have already been wrapped</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> promiseListener = process.addAsyncListener({
    <span class="hljs-attr">create</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params"></span>) </span>{
      instrumentPromise = <span class="hljs-literal">false</span>;
    }
  });

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<p>should not resolve synchronously</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  global.Promise.resolve(<span class="hljs-literal">true</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notSync</span>(<span class="hljs-params"></span>) </span>{
    instrumentPromise = <span class="hljs-literal">false</span>;
  });

  process.removeAsyncListener(promiseListener);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<div class="dox">
<div class="summary">
<p>Native promises use the microtask queue to make all callbacks run
asynchronously to avoid Zalgo issues. Since the microtask queue is not
exposed externally, promises need to be modified in a fairly invasive and
complex way.</p>
</div>
<div class="body">
<p>The async boundary in promises that must be patched is between the
fulfillment of the promise and the execution of any callback that is waiting
for that fulfillment to happen. This means that we need to trigger a create
when accept or reject is called and trigger before, after and error handlers
around the callback execution. There may be multiple callbacks for each
fulfilled promise, so handlers will behave similar to setInterval where
there may be multiple before after and error calls for each create call.</p>
<p>async-listener monkeypatching has one basic entry point: <code>wrapCallback</code>.
<code>wrapCallback</code> should be called when create should be triggered and be
passed a function to wrap, which will execute the body of the async work.
The accept and reject calls can be modified fairly easily to call
<code>wrapCallback</code>, but at the time of accept and reject all the work to be done
on fulfillment may not be defined, since a call to then, chain or fetch can
be made even after the promise has been fulfilled. To get around this, we
create a placeholder function which will call a function passed into it,
since the call to the main work is being made from within the wrapped
function, async-listener will work correctly.</p>
<p>There is another complication with monkeypatching Promises. Calls to then,
chain and catch each create new Promises that are fulfilled internally in
different ways depending on the return value of the callback. When the
callback return a Promise, the new Promise is resolved asynchronously after
the returned Promise has been also been resolved. When something other than
a promise is resolved the accept call for the new Promise is put in the
microtask queue and asynchronously resolved.</p>
<p>Then must be wrapped so that its returned promise has a wrapper that can be
used to invoke further continuations. This wrapper cannot be created until
after the callback has run, since the callback may return either a promise
or another value. Fortunately we already have a wrapper function around the
callback we can use (the wrapper created by accept or reject).</p>
<p>By adding an additional argument to this wrapper, we can pass in the
returned promise so it can have its own wrapper appended. the wrapper
function can the call the callback, and take action based on the return
value. If a promise is returned, the new Promise can proxy the returned
Promise's wrapper (this wrapper may not exist yet, but will by the time the
wrapper needs to be invoked). Otherwise, a new wrapper can be create the
same way as in accept and reject. Since this wrapper is created
synchronously within another wrapper, it will properly appear as a
continuation from within the callback.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-keyword">if</span> (instrumentPromise) {
  wrapPromise();
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapPromise</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> <span class="hljs-built_in">Promise</span> = global.Promise;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrappedPromise</span>(<span class="hljs-params">executor</span>) </span>{
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> wrappedPromise)) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>(executor);
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> executor !== <span class="hljs-string">'function'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(executor);
    }

    <span class="hljs-keyword">var</span> context, args;
    <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(wrappedExecutor);
    promise.__proto__ = wrappedPromise.prototype;

    <span class="hljs-keyword">try</span> {
      executor.apply(context, args);
    } <span class="hljs-keyword">catch</span> (err) {
      args[<span class="hljs-number">1</span>](err)
    }

    <span class="hljs-keyword">return</span> promise;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrappedExecutor</span>(<span class="hljs-params">accept, reject</span>) </span>{
      context = <span class="hljs-keyword">this</span>;
      args = [wrappedAccept, wrappedReject];

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<p>These wrappers create a function that can be passed a function and an argument to
call as a continuation from the accept or reject.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrappedAccept</span>(<span class="hljs-params">val</span>) </span>{
        ensureAslWrapper(promise, <span class="hljs-literal">false</span>);
        <span class="hljs-keyword">return</span> accept(val);
      }

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrappedReject</span>(<span class="hljs-params">val</span>) </span>{
        ensureAslWrapper(promise, <span class="hljs-literal">false</span>);
        <span class="hljs-keyword">return</span> reject(val);
      }
    }
  }

  util.inherits(wrappedPromise, <span class="hljs-built_in">Promise</span>);

  wrap(<span class="hljs-built_in">Promise</span>.prototype, <span class="hljs-string">'then'</span>, wrapThen);
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Promise</span>.prototype.chain) {
    wrap(<span class="hljs-built_in">Promise</span>.prototype, <span class="hljs-string">'chain'</span>, wrapThen);
  }

  <span class="hljs-keyword">var</span> PromiseMethods = [<span class="hljs-string">'accept'</span>, <span class="hljs-string">'all'</span>, <span class="hljs-string">'defer'</span>, <span class="hljs-string">'race'</span>, <span class="hljs-string">'reject'</span>, <span class="hljs-string">'resolve'</span>];

  PromiseMethods.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
    wrappedPromise[key] = <span class="hljs-built_in">Promise</span>[key];
  });

  global.Promise = wrappedPromise;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ensureAslWrapper</span>(<span class="hljs-params">promise, overwrite</span>) </span>{
    <span class="hljs-keyword">if</span> (!promise.__asl_wrapper || overwrite) {
      promise.__asl_wrapper = wrapCallback(propagateAslWrapper);
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">propagateAslWrapper</span>(<span class="hljs-params">ctx, fn, result, next</span>) </span>{
    <span class="hljs-keyword">var</span> nextResult;
    <span class="hljs-keyword">try</span> {
      nextResult = fn.call(ctx, result);
      <span class="hljs-keyword">return</span> {<span class="hljs-attr">returnVal</span>: nextResult, <span class="hljs-attr">error</span>: <span class="hljs-literal">false</span>}
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-keyword">return</span> {<span class="hljs-attr">errorVal</span>: err, <span class="hljs-attr">error</span>: <span class="hljs-literal">true</span>}
    } <span class="hljs-keyword">finally</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<p>Wrap any resulting futures as continuations.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (nextResult <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) {
        next.__asl_wrapper = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxyWrapper</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> aslWrapper = nextResult.__asl_wrapper || propagateAslWrapper;
          <span class="hljs-keyword">return</span> aslWrapper.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        }
      } <span class="hljs-keyword">else</span> {
        ensureAslWrapper(next, <span class="hljs-literal">true</span>);
      }
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapThen</span>(<span class="hljs-params">original</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrappedThen</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">this</span>;
      <span class="hljs-keyword">var</span> next = original.apply(promise, <span class="hljs-built_in">Array</span>.prototype.map.call(<span class="hljs-built_in">arguments</span>, bind));

      next.__asl_wrapper = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxyWrapper</span>(<span class="hljs-params">ctx, fn, val, last</span>) </span>{
        <span class="hljs-keyword">if</span> (promise.__asl_wrapper) {
          promise.__asl_wrapper(ctx, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}, <span class="hljs-literal">null</span>, next);
          <span class="hljs-keyword">return</span> next.__asl_wrapper(ctx, fn, val, last);
        }
        <span class="hljs-keyword">return</span> propagateAslWrapper(ctx, fn, val, last);
      }

      <span class="hljs-keyword">return</span> next;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<p>wrap callbacks (success, error) so that the callbacks will be called as a
continuations of the accept or reject call using the __asl_wrapper created above.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params">fn</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">'function'</span>) <span class="hljs-keyword">return</span> fn;
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>{
          <span class="hljs-keyword">var</span> result = (promise.__asl_wrapper || propagateAslWrapper)(<span class="hljs-keyword">this</span>, fn, val, next);
          <span class="hljs-keyword">if</span> (result.error) {
            <span class="hljs-keyword">throw</span> result.errorVal
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> result.returnVal
          }
        };
      }
    }
  }
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<p>Shim activator for functions that have callback last</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">activator</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">var</span> fallback = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> args;
    <span class="hljs-keyword">var</span> cbIdx = <span class="hljs-built_in">arguments</span>.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">arguments</span>[cbIdx] === <span class="hljs-string">"function"</span>) {
      args = <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">arguments</span>.length)
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length - <span class="hljs-number">1</span>; i++) {
        args[i] = <span class="hljs-built_in">arguments</span>[i];
      }
      args[cbIdx] = wrapCallback(<span class="hljs-built_in">arguments</span>[cbIdx]);
    }
    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, args || <span class="hljs-built_in">arguments</span>);
  };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<p>Preserve function length for small arg count functions.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">switch</span> (fn.length) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length !== <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> fallback.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cb === <span class="hljs-string">"function"</span>) cb = wrapCallback(cb);
        <span class="hljs-keyword">return</span> fn.call(<span class="hljs-keyword">this</span>, cb);
      };
    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, cb</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length !== <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> fallback.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cb === <span class="hljs-string">"function"</span>) cb = wrapCallback(cb);
        <span class="hljs-keyword">return</span> fn.call(<span class="hljs-keyword">this</span>, a, cb);
      };
    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, cb</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length !== <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> fallback.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cb === <span class="hljs-string">"function"</span>) cb = wrapCallback(cb);
        <span class="hljs-keyword">return</span> fn.call(<span class="hljs-keyword">this</span>, a, b, cb);
      };
    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, cb</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> fallback.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cb === <span class="hljs-string">"function"</span>) cb = wrapCallback(cb);
        <span class="hljs-keyword">return</span> fn.call(<span class="hljs-keyword">this</span>, a, b, c, cb);
      };
    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d, cb</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length !== <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span> fallback.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cb === <span class="hljs-string">"function"</span>) cb = wrapCallback(cb);
        <span class="hljs-keyword">return</span> fn.call(<span class="hljs-keyword">this</span>, a, b, c, d, cb);
      };
    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d, e, cb</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length !== <span class="hljs-number">6</span>) <span class="hljs-keyword">return</span> fallback.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cb === <span class="hljs-string">"function"</span>) cb = wrapCallback(cb);
        <span class="hljs-keyword">return</span> fn.call(<span class="hljs-keyword">this</span>, a, b, c, d, e, cb);
      };
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> fallback;
  }
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<p>Shim activator for functions that have callback first</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">activatorFirst</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">var</span> fallback = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> args;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] === <span class="hljs-string">"function"</span>) {
      args = <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">arguments</span>.length)
      args[<span class="hljs-number">0</span>] = wrapCallback(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) {
        args[i] = <span class="hljs-built_in">arguments</span>[i];
      }
    }
    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, args || <span class="hljs-built_in">arguments</span>);
  };
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-32" id="section-32"></a>
</div>
<p>Preserve function length for small arg count functions.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">switch</span> (fn.length) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length !== <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> fallback.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cb === <span class="hljs-string">"function"</span>) cb = wrapCallback(cb);
        <span class="hljs-keyword">return</span> fn.call(<span class="hljs-keyword">this</span>, cb);
      };
    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb, a</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length !== <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> fallback.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cb === <span class="hljs-string">"function"</span>) cb = wrapCallback(cb);
        <span class="hljs-keyword">return</span> fn.call(<span class="hljs-keyword">this</span>, cb, a);
      };
    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb, a, b</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length !== <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> fallback.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cb === <span class="hljs-string">"function"</span>) cb = wrapCallback(cb);
        <span class="hljs-keyword">return</span> fn.call(<span class="hljs-keyword">this</span>, cb, a, b);
      };
    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb, a, b, c</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> fallback.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cb === <span class="hljs-string">"function"</span>) cb = wrapCallback(cb);
        <span class="hljs-keyword">return</span> fn.call(<span class="hljs-keyword">this</span>, cb, a, b, c);
      };
    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb, a, b, c, d</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length !== <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span> fallback.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cb === <span class="hljs-string">"function"</span>) cb = wrapCallback(cb);
        <span class="hljs-keyword">return</span> fn.call(<span class="hljs-keyword">this</span>, cb, a, b, c, d);
      };
    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cb, a, b, c, d, e</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length !== <span class="hljs-number">6</span>) <span class="hljs-keyword">return</span> fallback.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cb === <span class="hljs-string">"function"</span>) cb = wrapCallback(cb);
        <span class="hljs-keyword">return</span> fn.call(<span class="hljs-keyword">this</span>, cb, a, b, c, d, e);
      };
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> fallback;
  }
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-33" id="section-33"></a>
</div>
<p>taken from node master on 2017/03/09</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toNumber</span>(<span class="hljs-params">x</span>) </span>{
  <span class="hljs-keyword">return</span> (x = <span class="hljs-built_in">Number</span>(x)) &gt;= <span class="hljs-number">0</span> ? x : <span class="hljs-literal">false</span>;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-34" id="section-34"></a>
</div>
<p>taken from node master on 2017/03/09</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPipeName</span>(<span class="hljs-params">s</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> s === <span class="hljs-string">'string'</span> &amp;&amp; toNumber(s) === <span class="hljs-literal">false</span>;
}

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
