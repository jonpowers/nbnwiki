<!DOCTYPE html>
<html>
<head>
  <title>glue.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/async-listener/glue.js";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>glue.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> wrap = <span class="hljs-built_in">require</span>(<span class="hljs-string">'shimmer'</span>).wrap;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<div class="dox">
<div class="summary">
<p>CONSTANTS</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> HAS_CREATE_AL = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> HAS_BEFORE_AL = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> HAS_AFTER_AL = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;
<span class="hljs-keyword">var</span> HAS_ERROR_AL = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<div class="dox">
<div class="summary">
<p>There is one list of currently active listeners that is mutated in place by
addAsyncListener and removeAsyncListener. This complicates error-handling,
for reasons that are discussed below.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> listeners = [];

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<div class="dox">
<div class="summary">
<p>There can be multiple listeners with the same properties, so disambiguate
them by assigning them an ID at creation time.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> uid = <span class="hljs-number">0</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<div class="dox">
<div class="summary">
<p>Ensure that errors coming from within listeners are handed off to domains,
process._fatalException, or uncaughtException without being treated like
user errors.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> inAsyncTick = <span class="hljs-literal">false</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<div class="dox">
<div class="summary">
<p>Because asynchronous contexts can be nested, and errors can come from anywhere
in the stack, a little extra work is required to keep track of where in the
nesting we are. Because JS arrays are frequently mutated in place</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> listenerStack = [];

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<div class="dox">
<div class="summary">
<p>The error handler on a listener can capture errors thrown during synchronous
execution immediately after the listener is added. To capture both
synchronous and asynchronous errors, the error handler just uses the
&quot;global&quot; list of active listeners, and the rest of the code ensures that the
listener list is correct by using a stack of listener lists during
asynchronous execution.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> asyncCatcher;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<div class="dox">
<div class="summary">
<p>The guts of the system -- called each time an asynchronous event happens
while one or more listeners are active.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> asyncWrap;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<div class="dox">
<div class="summary">
<p>Simple helper function that's probably faster than using Array
filter methods and can be inlined.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">union</span>(<span class="hljs-params">dest, added</span>) </span>{
  <span class="hljs-keyword">var</span> destLength = dest.length;
  <span class="hljs-keyword">var</span> addedLength = added.length;
  <span class="hljs-keyword">var</span> returned = [];

  <span class="hljs-keyword">if</span> (destLength === <span class="hljs-number">0</span> &amp;&amp; addedLength === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> returned;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j  = <span class="hljs-number">0</span>; j &lt; destLength; j++) returned[j] = dest[j];

  <span class="hljs-keyword">if</span> (addedLength === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> returned;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; addedLength; i++) {
    <span class="hljs-keyword">var</span> missing = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; destLength; j++) {
      <span class="hljs-keyword">if</span> (dest[j].uid === added[i].uid) {
        missing = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">break</span>;
      }
    }
    <span class="hljs-keyword">if</span> (missing) returned.push(added[i]);
  }

  <span class="hljs-keyword">return</span> returned;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<div class="dox">
<div class="summary">
<p>For performance, split error-handlers and asyncCatcher up into two separate
code paths.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>0.9+</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">if</span> (process._fatalException) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<div class="dox">
<div class="summary">
<p>Error handlers on listeners can throw, the catcher needs to be able to
discriminate between exceptions thrown by user code, and exceptions coming
from within the catcher itself. Use a global to keep track of which state
the catcher is currently in.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> inErrorTick = <span class="hljs-literal">false</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<div class="dox">
<div class="summary">
<p>Throwing always happens synchronously. If the current array of values for
the current list of asyncListeners is put in a module-scoped variable right
before a call that can throw, it will always be correct when the error
handlers are run.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> errorValues;

  asyncCatcher = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncCatcher</span>(<span class="hljs-params">er</span>) </span>{
    <span class="hljs-keyword">var</span> length = listeners.length;
    <span class="hljs-keyword">if</span> (inErrorTick || length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">var</span> handled = <span class="hljs-literal">false</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<div class="dox">
<div class="summary">
<p>error handlers</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    inErrorTick = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) {
      <span class="hljs-keyword">var</span> listener = listeners[i];
      <span class="hljs-keyword">if</span> ((listener.flags &amp; HAS_ERROR_AL) === <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;

      <span class="hljs-keyword">var</span> value = errorValues &amp;&amp; errorValues[listener.uid];
      handled = listener.error(value, er) || handled;
    }
    inErrorTick = <span class="hljs-literal">false</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<div class="dox">
<div class="summary">
<p>Test whether there are any listener arrays on the stack. In the case of
synchronous throws when the listener is active, there may have been
none pushed yet.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (listenerStack.length &gt; <span class="hljs-number">0</span>) listeners = listenerStack.pop();
    errorValues = <span class="hljs-literal">undefined</span>;

    <span class="hljs-keyword">return</span> handled &amp;&amp; !inAsyncTick;
  };

  asyncWrap = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncWrap</span>(<span class="hljs-params">original, list, length</span>) </span>{
    <span class="hljs-keyword">var</span> values = [];

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<div class="dox">
<div class="summary">
<p>listeners</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    inAsyncTick = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) {
      <span class="hljs-keyword">var</span> listener = list[i];
      values[listener.uid] = listener.data;

      <span class="hljs-keyword">if</span> ((listener.flags &amp; HAS_CREATE_AL) === <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;

      <span class="hljs-keyword">var</span> value = listener.create(listener.data);
      <span class="hljs-keyword">if</span> (value !== <span class="hljs-literal">undefined</span>) values[listener.uid] = value;
    }
    inAsyncTick = <span class="hljs-literal">false</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<div class="dox">
<div class="summary">
<p>One of the main differences between this polyfill and the core
asyncListener support is that core avoids creating closures by putting a
lot of the state managemnt on the C++ side of Node (and of course also it
bakes support for async listeners into the Node C++ API through the
AsyncWrap class, which means that it doesn't monkeypatch basically every
async method like this does).</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>put the current values where the catcher can see them</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      errorValues = values;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<div class="dox">
<div class="summary">
<p>More than one listener can end up inside these closures, so save the
current listeners on a stack.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">      listenerStack.push(listeners);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<div class="dox">
<div class="summary">
<p>Activate both the listeners that were active when the closure was
created and the listeners that were previously active.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">      listeners = union(list, listeners);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<div class="dox">
<div class="summary">
<p>before handlers</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">      inAsyncTick = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) {
        <span class="hljs-keyword">if</span> ((list[i].flags &amp; HAS_BEFORE_AL) &gt; <span class="hljs-number">0</span>) {
          list[i].before(<span class="hljs-keyword">this</span>, values[list[i].uid]);
        }
      }
      inAsyncTick = <span class="hljs-literal">false</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>save the return value to pass to the after callbacks</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> returned = original.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<div class="dox">
<div class="summary">
<p>after handlers (not run if original throws)</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">      inAsyncTick = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; ++i) {
        <span class="hljs-keyword">if</span> ((list[i].flags &amp; HAS_AFTER_AL) &gt; <span class="hljs-number">0</span>) {
          list[i].after(<span class="hljs-keyword">this</span>, values[list[i].uid]);
        }
      }
      inAsyncTick = <span class="hljs-literal">false</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<p>back to the previous listener list on the stack</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      listeners = listenerStack.pop();
      errorValues = <span class="hljs-literal">undefined</span>;

      <span class="hljs-keyword">return</span> returned;
    };
  };

  wrap(process, <span class="hljs-string">'_fatalException'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_fatalException</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_asyncFatalException</span>(<span class="hljs-params">er</span>) </span>{
      <span class="hljs-keyword">return</span> asyncCatcher(er) || _fatalException(er);
    };
  });
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<p>0.8 and below</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<div class="dox">
<div class="summary">
<p>If an error handler in asyncWrap throws, the process must die. Under 0.8
and earlier the only way to put a bullet through the head of the process
is to rethrow from inside the exception handler, so rethrow and set
errorThrew to tell the uncaughtHandler what to do.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> errorThrew = <span class="hljs-literal">false</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<div class="dox">
<div class="summary">
<p>Under Node 0.8, this handler <em>only</em> handles synchronously thrown errors.
This simplifies it, which almost but not quite makes up for the hit taken
by putting everything in a try-catch.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  asyncCatcher = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uncaughtCatcher</span>(<span class="hljs-params">er</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<p>going down hard</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (errorThrew) <span class="hljs-keyword">throw</span> er;

    <span class="hljs-keyword">var</span> handled = <span class="hljs-literal">false</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<div class="dox">
<div class="summary">
<p>error handlers</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> length = listeners.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) {
      <span class="hljs-keyword">var</span> listener = listeners[i];
      <span class="hljs-keyword">if</span> ((listener.flags &amp; HAS_ERROR_AL) === <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
      handled = listener.error(<span class="hljs-literal">null</span>, er) || handled;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<div class="dox">
<div class="summary">
<p>Rethrow if one of the before / after handlers fire, which will bring the
process down immediately.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (!handled &amp;&amp; inAsyncTick) <span class="hljs-keyword">throw</span> er;
  };

  asyncWrap = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncWrap</span>(<span class="hljs-params">original, list, length</span>) </span>{
    <span class="hljs-keyword">var</span> values = [];

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<div class="dox">
<div class="summary">
<p>listeners</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    inAsyncTick = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) {
      <span class="hljs-keyword">var</span> listener = list[i];
      values[listener.uid] = listener.data;

      <span class="hljs-keyword">if</span> ((listener.flags &amp; HAS_CREATE_AL) === <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;

      <span class="hljs-keyword">var</span> value = listener.create(listener.data);
      <span class="hljs-keyword">if</span> (value !== <span class="hljs-literal">undefined</span>) values[listener.uid] = value;
    }
    inAsyncTick = <span class="hljs-literal">false</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-32" id="section-32"></a>
</div>
<div class="dox">
<div class="summary">
<p>One of the main differences between this polyfill and the core
asyncListener support is that core avoids creating closures by putting a
lot of the state managemnt on the C++ side of Node (and of course also it
bakes support for async listeners into the Node C++ API through the
AsyncWrap class, which means that it doesn't monkeypatch basically every
async method like this does).</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-comment">/*jshint maxdepth:4*/</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-33" id="section-33"></a>
</div>
<p>after() handlers don't run if threw</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> threw = <span class="hljs-literal">false</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-34" id="section-34"></a>
</div>
<p>...unless the error is handled</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> handled = <span class="hljs-literal">false</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-35" id="section-35"></a>
</div>
<div class="dox">
<div class="summary">
<p>More than one listener can end up inside these closures, so save the
current listeners on a stack.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">      listenerStack.push(listeners);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-36" id="section-36"></a>
</div>
<div class="dox">
<div class="summary">
<p>Activate both the listeners that were active when the closure was
created and the listeners that were previously active.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">      listeners = union(list, listeners);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-37" id="section-37"></a>
</div>
<div class="dox">
<div class="summary">
<p>before handlers</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">      inAsyncTick = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) {
        <span class="hljs-keyword">if</span> ((list[i].flags &amp; HAS_BEFORE_AL) &gt; <span class="hljs-number">0</span>) {
          list[i].before(<span class="hljs-keyword">this</span>, values[list[i].uid]);
        }
      }
      inAsyncTick = <span class="hljs-literal">false</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-38" id="section-38"></a>
</div>
<p>save the return value to pass to the after callbacks</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> returned;
      <span class="hljs-keyword">try</span> {
        returned = original.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
      }
      <span class="hljs-keyword">catch</span> (er) {
        threw = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) {
          <span class="hljs-keyword">if</span> ((listeners[i].flags &amp; HAS_ERROR_AL) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
          <span class="hljs-keyword">try</span> {
            handled = listeners[i].error(values[list[i].uid], er) || handled;
          }
          <span class="hljs-keyword">catch</span> (x) {
            errorThrew = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">throw</span> x;
          }
        }

        <span class="hljs-keyword">if</span> (!handled) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-39" id="section-39"></a>
</div>
<p>having an uncaughtException handler here alters crash semantics</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          process.removeListener(<span class="hljs-string">'uncaughtException'</span>, asyncCatcher);
          process._originalNextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            process.addListener(<span class="hljs-string">'uncaughtException'</span>, asyncCatcher);
          });

          <span class="hljs-keyword">throw</span> er;
        }
      }
      <span class="hljs-keyword">finally</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-40" id="section-40"></a>
</div>
<div class="dox">
<div class="summary">
<p>after handlers (not run if original throws)</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (!threw || handled) {
          inAsyncTick = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; ++i) {
            <span class="hljs-keyword">if</span> ((list[i].flags &amp; HAS_AFTER_AL) &gt; <span class="hljs-number">0</span>) {
              list[i].after(<span class="hljs-keyword">this</span>, values[list[i].uid]);
            }
          }
          inAsyncTick = <span class="hljs-literal">false</span>;
        }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-41" id="section-41"></a>
</div>
<p>back to the previous listener list on the stack</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        listeners = listenerStack.pop();
      }


      <span class="hljs-keyword">return</span> returned;
    };
  };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-42" id="section-42"></a>
</div>
<p>will be the first to fire if async-listener is the first module loaded</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  process.addListener(<span class="hljs-string">'uncaughtException'</span>, asyncCatcher);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-43" id="section-43"></a>
</div>
<p>for performance in the case where there are no handlers, just the listener</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">simpleWrap</span>(<span class="hljs-params">original, list, length</span>) </span>{
  inAsyncTick = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) {
    <span class="hljs-keyword">var</span> listener = list[i];
    <span class="hljs-keyword">if</span> (listener.create) listener.create(listener.data);
  }
  inAsyncTick = <span class="hljs-literal">false</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-44" id="section-44"></a>
</div>
<p>still need to make sure nested async calls are made in the context
of the listeners active at their creation</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    listenerStack.push(listeners);
    listeners = union(list, listeners);

    <span class="hljs-keyword">var</span> returned = original.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);

    listeners = listenerStack.pop();

    <span class="hljs-keyword">return</span> returned;
  };
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-45" id="section-45"></a>
</div>
<div class="dox">
<div class="summary">
<p>Called each time an asynchronous function that's been monkeypatched in
index.js is called. If there are no listeners, return the function
unwrapped.  If there are any asyncListeners and any of them have callbacks,
pass them off to asyncWrap for later use, otherwise just call the listener.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapCallback</span>(<span class="hljs-params">original</span>) </span>{
  <span class="hljs-keyword">var</span> length = listeners.length;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-46" id="section-46"></a>
</div>
<p>no context to capture, so avoid closure creation</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> original;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-47" id="section-47"></a>
</div>
<p>capture the active listeners as of when the wrapped function was called</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> list = listeners.slice();

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) {
    <span class="hljs-keyword">if</span> (list[i].flags &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> asyncWrap(original, list, length);
  }

  <span class="hljs-keyword">return</span> simpleWrap(original, list, length);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AsyncListener</span>(<span class="hljs-params">callbacks, data</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callbacks.create === <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">this</span>.create = callbacks.create;
    <span class="hljs-keyword">this</span>.flags |= HAS_CREATE_AL;
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callbacks.before === <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">this</span>.before = callbacks.before;
    <span class="hljs-keyword">this</span>.flags |= HAS_BEFORE_AL;
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callbacks.after === <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">this</span>.after = callbacks.after;
    <span class="hljs-keyword">this</span>.flags |= HAS_AFTER_AL;
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callbacks.error === <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">this</span>.error = callbacks.error;
    <span class="hljs-keyword">this</span>.flags |= HAS_ERROR_AL;
  }

  <span class="hljs-keyword">this</span>.uid = ++uid;
  <span class="hljs-keyword">this</span>.data = data === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : data;
}
AsyncListener.prototype.create = <span class="hljs-literal">undefined</span>;
AsyncListener.prototype.before = <span class="hljs-literal">undefined</span>;
AsyncListener.prototype.after  = <span class="hljs-literal">undefined</span>;
AsyncListener.prototype.error  = <span class="hljs-literal">undefined</span>;
AsyncListener.prototype.data   = <span class="hljs-literal">undefined</span>;
AsyncListener.prototype.uid    = <span class="hljs-number">0</span>;
AsyncListener.prototype.flags  = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createAsyncListener</span>(<span class="hljs-params">callbacks, data</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callbacks !== <span class="hljs-string">'object'</span> || !callbacks) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'callbacks argument must be an object'</span>);
  }

  <span class="hljs-keyword">if</span> (callbacks <span class="hljs-keyword">instanceof</span> AsyncListener) {
    <span class="hljs-keyword">return</span> callbacks;
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AsyncListener(callbacks, data);
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAsyncListener</span>(<span class="hljs-params">callbacks, data</span>) </span>{
  <span class="hljs-keyword">var</span> listener;
  <span class="hljs-keyword">if</span> (!(callbacks <span class="hljs-keyword">instanceof</span> AsyncListener)) {
    listener = createAsyncListener(callbacks, data);
  }
  <span class="hljs-keyword">else</span> {
    listener = callbacks;
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-48" id="section-48"></a>
</div>
<p>Make sure the listener isn't already in the list.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> registered = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; listeners.length; i++) {
    <span class="hljs-keyword">if</span> (listener === listeners[i]) {
      registered = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-keyword">if</span> (!registered) listeners.push(listener);

  <span class="hljs-keyword">return</span> listener;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeAsyncListener</span>(<span class="hljs-params">listener</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; listeners.length; i++) {
    <span class="hljs-keyword">if</span> (listener === listeners[i]) {
      listeners.splice(i, <span class="hljs-number">1</span>);
      <span class="hljs-keyword">break</span>;
    }
  }
}

process.createAsyncListener = createAsyncListener;
process.addAsyncListener    = addAsyncListener;
process.removeAsyncListener = removeAsyncListener;

<span class="hljs-built_in">module</span>.exports = wrapCallback;

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
