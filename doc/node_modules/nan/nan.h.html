<!DOCTYPE html>
<html>
<head>
  <title>nan.h</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/nan/nan.h";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>nan.h</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>
<div class="dox">
<div class="summary">
<hr>
<p>NAN - Native Abstractions for Node.js</p>
</div>
<div class="body">
<p>Copyright (c) 2016 NAN contributors:</p>
<ul>
<li>Rod Vagg <a href="https://github.com/rvagg">https://github.com/rvagg</a></li>
<li>Benjamin Byholm <a href="https://github.com/kkoopa">https://github.com/kkoopa</a></li>
<li>Trevor Norris <a href="https://github.com/trevnorris">https://github.com/trevnorris</a></li>
<li>Nathan Rajlich <a href="https://github.com/TooTallNate">https://github.com/TooTallNate</a></li>
<li>Brett Lawson <a href="https://github.com/brett19">https://github.com/brett19</a></li>
<li>Ben Noordhuis <a href="https://github.com/bnoordhuis">https://github.com/bnoordhuis</a></li>
<li>David Siegel <a href="https://github.com/agnat">https://github.com/agnat</a></li>
</ul>
<p>MIT License <a href="https://github.com/nodejs/nan/blob/master/LICENSE.md">https://github.com/nodejs/nan/blob/master/LICENSE.md</a></p>
<p>Version 2.3.5: current Node 6.2.0, Node 12: 0.12.14, Node 10: 0.10.45, iojs: 3.3.1</p>
<p>See https://github.com/nodejs/nan for the latest update to this file</p>
<hr>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NAN_H_</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NAN_H_</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;node_version.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NODE_0_10_MODULE_VERSION 11</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NODE_0_12_MODULE_VERSION 14</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ATOM_0_21_MODULE_VERSION 41</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IOJS_1_0_MODULE_VERSION  42</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IOJS_1_1_MODULE_VERSION  43</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IOJS_2_0_MODULE_VERSION  44</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IOJS_3_0_MODULE_VERSION  45</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NODE_4_0_MODULE_VERSION  46</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NODE_5_0_MODULE_VERSION  47</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NODE_6_0_MODULE_VERSION  48</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _MSC_VER</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> NAN_HAS_CPLUSPLUS_11 (_MSC_VER &gt;= 1800)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> NAN_HAS_CPLUSPLUS_11 (__cplusplus &gt;= 201103L)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &gt;= IOJS_3_0_MODULE_VERSION &amp;&amp; !NAN_HAS_CPLUSPLUS_11</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">error</span> This version of node/NAN/v8 requires a C++11 compiler</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;uv.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;node.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;node_buffer.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;node_object_wrap.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;climits&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(_MSC_VER)</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span>( push )</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span>( disable : 4530 )</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span>( pop )</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>uv helpers</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> UV_VERSION_MAJOR</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">ifndef</span> UV_VERSION_PATCH</span>
<span class="hljs-meta">#  <span class="hljs-meta-keyword">define</span> UV_VERSION_PATCH 0</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">endif</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> NAUV_UVVERSION ((UV_VERSION_MAJOR &lt;&lt; 16) | \
                         (UV_VERSION_MINOR &lt;&lt;  8) | \
                         (UV_VERSION_PATCH))</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> NAUV_UVVERSION 0x000b00</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NAUV_UVVERSION &lt; 0x000b0b</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">ifdef</span> WIN32</span>
<span class="hljs-meta">#  <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta">#  <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-keyword">namespace</span> Nan {

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NAN_INLINE inline  <span class="hljs-comment">// TODO(bnoordhuis) Remove in v3.0.0.</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__GNUC__) &amp;&amp; \
    !(defined(V8_DISABLE_DEPRECATIONS) &amp;&amp; V8_DISABLE_DEPRECATIONS)</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> NAN_DEPRECATED __attribute__((deprecated))</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> defined(_MSC_VER) &amp;&amp; \
    !(defined(V8_DISABLE_DEPRECATIONS) &amp;&amp; V8_DISABLE_DEPRECATIONS)</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> NAN_DEPRECATED __declspec(deprecated)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> NAN_DEPRECATED</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NAN_HAS_CPLUSPLUS_11</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> NAN_DISALLOW_ASSIGN(CLASS) void operator=(const CLASS&amp;) = delete;</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> NAN_DISALLOW_COPY(CLASS) CLASS(const CLASS&amp;) = delete;</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> NAN_DISALLOW_MOVE(CLASS)                                              \
    CLASS(CLASS&amp;&amp;) = delete;  <span class="hljs-comment">/* NOLINT(build/c++11) */</span>                        \
    void operator=(CLASS&amp;&amp;) = delete;</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> NAN_DISALLOW_ASSIGN(CLASS) void operator=(const CLASS&amp;);</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> NAN_DISALLOW_COPY(CLASS) CLASS(const CLASS&amp;);</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> NAN_DISALLOW_MOVE(CLASS)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NAN_DISALLOW_ASSIGN_COPY(CLASS)                                        \
    NAN_DISALLOW_ASSIGN(CLASS)                                                 \
    NAN_DISALLOW_COPY(CLASS)</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NAN_DISALLOW_ASSIGN_MOVE(CLASS)                                        \
    NAN_DISALLOW_ASSIGN(CLASS)                                                 \
    NAN_DISALLOW_MOVE(CLASS)</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NAN_DISALLOW_COPY_MOVE(CLASS)                                          \
    NAN_DISALLOW_COPY(CLASS)                                                   \
    NAN_DISALLOW_MOVE(CLASS)</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NAN_DISALLOW_ASSIGN_COPY_MOVE(CLASS)                                   \
    NAN_DISALLOW_ASSIGN(CLASS)                                                 \
    NAN_DISALLOW_COPY(CLASS)                                                   \
    NAN_DISALLOW_MOVE(CLASS)</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TYPE_CHECK(T, S)                                                       \
    while (false) {                                                            \
      *(static_cast<span class="hljs-meta-string">&lt;T *volatile *&gt;(0)) = static_cast&lt;S*&gt;(0);                   \</span></span>
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>=== RegistrationFunction =====================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION</span>
  <span class="hljs-keyword">typedef</span> v8::Handle&lt;v8::Object&gt; ADDON_REGISTER_FUNCTION_ARGS_TYPE;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">typedef</span> v8::Local&lt;v8::Object&gt; ADDON_REGISTER_FUNCTION_ARGS_TYPE;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NAN_MODULE_INIT(name)                                                  \
    void name(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target)</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>=== CallbackInfo =============================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nan_callbacks.h"</span>  <span class="hljs-comment">// NOLINT(build/include)</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>==============================================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (NODE_MODULE_VERSION &lt; NODE_0_12_MODULE_VERSION)</span>
<span class="hljs-keyword">typedef</span> v8::Script             UnboundScript;
<span class="hljs-keyword">typedef</span> v8::Script             BoundScript;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-keyword">typedef</span> v8::UnboundScript      UnboundScript;
<span class="hljs-keyword">typedef</span> v8::Script             BoundScript;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (NODE_MODULE_VERSION &lt; ATOM_0_21_MODULE_VERSION)</span>
<span class="hljs-keyword">typedef</span> v8::String::ExternalAsciiStringResource
    ExternalOneByteStringResource;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-keyword">typedef</span> v8::String::ExternalOneByteStringResource
    ExternalOneByteStringResource;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION)</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> NonCopyablePersistentTraits :
    <span class="hljs-keyword">public</span> v8::NonCopyablePersistentTraits&lt;T&gt; {};
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> CopyablePersistentTraits :
    <span class="hljs-keyword">public</span> v8::CopyablePersistentTraits&lt;T&gt; {};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> PersistentBase :
    <span class="hljs-keyword">public</span> v8::PersistentBase&lt;T&gt; {};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> M = v8::NonCopyablePersistentTraits&lt;T&gt; &gt;
<span class="hljs-keyword">class</span> Persistent;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> NonCopyablePersistentTraits;
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> PersistentBase;
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> P&gt; <span class="hljs-keyword">class</span> WeakCallbackData;
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> M = NonCopyablePersistentTraits&lt;T&gt; &gt;
<span class="hljs-keyword">class</span> Persistent;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NODE_MODULE_VERSION</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(V8_MAJOR_VERSION) &amp;&amp; (V8_MAJOR_VERSION &gt; 4 ||                      \
  (V8_MAJOR_VERSION == 4 &amp;&amp; defined(V8_MINOR_VERSION) &amp;&amp; V8_MINOR_VERSION &gt;= 3))</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nan_maybe_43_inl.h"</span>  <span class="hljs-comment">// NOLINT(build/include)</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nan_maybe_pre_43_inl.h"</span>  <span class="hljs-comment">// NOLINT(build/include)</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nan_converters.h"</span>  <span class="hljs-comment">// NOLINT(build/include)</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nan_new.h"</span>  <span class="hljs-comment">// NOLINT(build/include)</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NAUV_UVVERSION &lt; 0x000b17</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NAUV_WORK_CB(func) \
    void func(uv_async_t *async, int)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NAUV_WORK_CB(func) \
    void func(uv_async_t *async)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NAUV_UVVERSION &gt;= 0x000b0b</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uv_key_t</span> <span class="hljs-keyword">nauv_key_t</span>;

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nauv_key_create</span><span class="hljs-params">(<span class="hljs-keyword">nauv_key_t</span> *key)</span> </span>{
  <span class="hljs-keyword">return</span> uv_key_create(key);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nauv_key_delete</span><span class="hljs-params">(<span class="hljs-keyword">nauv_key_t</span> *key)</span> </span>{
  uv_key_delete(key);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>* <span class="hljs-title">nauv_key_get</span><span class="hljs-params">(<span class="hljs-keyword">nauv_key_t</span> *key)</span> </span>{
  <span class="hljs-keyword">return</span> uv_key_get(key);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nauv_key_set</span><span class="hljs-params">(<span class="hljs-keyword">nauv_key_t</span> *key, <span class="hljs-keyword">void</span> *value)</span> </span>{
  uv_key_set(key, value);
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<div class="dox">
<div class="summary">
<p>Implement thread local storage for older versions of libuv.
This is essentially a backport of libuv commit 5d2434bf
written by Ben Noordhuis, adjusted for names and inline.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> WIN32</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">pthread_key_t</span> <span class="hljs-keyword">nauv_key_t</span>;

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nauv_key_create</span><span class="hljs-params">(<span class="hljs-keyword">nauv_key_t</span>* key)</span> </span>{
  <span class="hljs-keyword">return</span> -pthread_key_create(key, <span class="hljs-literal">NULL</span>);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nauv_key_delete</span><span class="hljs-params">(<span class="hljs-keyword">nauv_key_t</span>* key)</span> </span>{
  <span class="hljs-keyword">if</span> (pthread_key_delete(*key))
    <span class="hljs-built_in">abort</span>();
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>* <span class="hljs-title">nauv_key_get</span><span class="hljs-params">(<span class="hljs-keyword">nauv_key_t</span>* key)</span> </span>{
  <span class="hljs-keyword">return</span> pthread_getspecific(*key);
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nauv_key_set</span><span class="hljs-params">(<span class="hljs-keyword">nauv_key_t</span>* key, <span class="hljs-keyword">void</span>* value)</span> </span>{
  <span class="hljs-keyword">if</span> (pthread_setspecific(*key, value))
    <span class="hljs-built_in">abort</span>();
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {
  DWORD tls_index;
} <span class="hljs-keyword">nauv_key_t</span>;

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nauv_key_create</span><span class="hljs-params">(<span class="hljs-keyword">nauv_key_t</span>* key)</span> </span>{
  key-&gt;tls_index = TlsAlloc();
  <span class="hljs-keyword">if</span> (key-&gt;tls_index == TLS_OUT_OF_INDEXES)
    <span class="hljs-keyword">return</span> UV_ENOMEM;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nauv_key_delete</span><span class="hljs-params">(<span class="hljs-keyword">nauv_key_t</span>* key)</span> </span>{
  <span class="hljs-keyword">if</span> (TlsFree(key-&gt;tls_index) == FALSE)
    <span class="hljs-built_in">abort</span>();
  key-&gt;tls_index = TLS_OUT_OF_INDEXES;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>* <span class="hljs-title">nauv_key_get</span><span class="hljs-params">(<span class="hljs-keyword">nauv_key_t</span>* key)</span> </span>{
  <span class="hljs-keyword">void</span>* value = TlsGetValue(key-&gt;tls_index);
  <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">if</span> (GetLastError() != ERROR_SUCCESS)
      <span class="hljs-built_in">abort</span>();
  <span class="hljs-keyword">return</span> value;
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nauv_key_set</span><span class="hljs-params">(<span class="hljs-keyword">nauv_key_t</span>* key, <span class="hljs-keyword">void</span>* value)</span> </span>{
  <span class="hljs-keyword">if</span> (TlsSetValue(key-&gt;tls_index, value) == FALSE)
    <span class="hljs-built_in">abort</span>();
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
v8::Local&lt;T&gt; New(v8::Handle&lt;T&gt;);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(V8_MAJOR_VERSION) &amp;&amp; (V8_MAJOR_VERSION &gt; 4 ||                      \
  (V8_MAJOR_VERSION == 4 &amp;&amp; defined(V8_MINOR_VERSION) &amp;&amp; V8_MINOR_VERSION &gt;= 3))</span>
  <span class="hljs-keyword">typedef</span> v8::WeakCallbackType WeakCallbackType;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-keyword">struct</span> WeakCallbackType {
  <span class="hljs-keyword">enum</span> E {kParameter, kInternalFields};
  E type;
  WeakCallbackType(E other) : type(other) {}  <span class="hljs-comment">// NOLINT(runtime/explicit)</span>
  <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(E other) { <span class="hljs-keyword">return</span> other == <span class="hljs-keyword">this</span>-&gt;type; }
  <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(E other) { <span class="hljs-keyword">return</span> !<span class="hljs-keyword">operator</span>==(other); }
};
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> P&gt; <span class="hljs-keyword">class</span> WeakCallbackInfo;

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nan_persistent_12_inl.h"</span>  <span class="hljs-comment">// NOLINT(build/include)</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nan_persistent_pre_12_inl.h"</span>  <span class="hljs-comment">// NOLINT(build/include)</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-keyword">namespace</span> imp {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> kMaxLength = <span class="hljs-number">0x3fffffff</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>v8::String::REPLACE_INVALID_UTF8 was introduced
in node.js v0.10.29 and v0.8.27.</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NODE_MAJOR_VERSION &gt; 0 || \
    NODE_MINOR_VERSION &gt; 10 || \
    NODE_MINOR_VERSION == 10 &amp;&amp; NODE_PATCH_VERSION &gt;= 29 || \
    NODE_MINOR_VERSION == 8 &amp;&amp; NODE_PATCH_VERSION &gt;= 27</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> kReplaceInvalidUtf8 = v8::String::REPLACE_INVALID_UTF8;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> kReplaceInvalidUtf8 = <span class="hljs-number">0</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}  <span class="hljs-comment">// end of namespace imp</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>=== HandleScope ==============================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
class HandleScope {
  v8::HandleScope scope;

 public:
#if NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION
  inline HandleScope() : scope(v8::Isolate::GetCurrent()) {}
  inline static int NumberOfHandles() {
    return v8::HandleScope::NumberOfHandles(v8::Isolate::GetCurrent());
  }
#else
  inline HandleScope() : scope() {}
  inline static int NumberOfHandles() {
    return v8::HandleScope::NumberOfHandles();
  }
#endif

 private:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>Make it hard to create heap-allocated or illegal handle scopes by
disallowing certain operations.</p>

        </td>
        <td class="code highlight">
          <pre class="c">  HandleScope(const HandleScope &amp;);
  void operator=(const HandleScope &amp;);
  void *operator new(size_t size);
  void operator delete(void *, size_t);
};

class EscapableHandleScope {
 public:
#if NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION
  inline EscapableHandleScope() : scope(v8::Isolate::GetCurrent()) {}

  inline static int NumberOfHandles() {
    return v8::EscapableHandleScope::NumberOfHandles(v8::Isolate::GetCurrent());
  }

  template&lt;typename T&gt;
  inline v8::Local&lt;T&gt; Escape(v8::Local&lt;T&gt; value) {
    return scope.Escape(value);
  }

 private:
  v8::EscapableHandleScope scope;
#else
  inline EscapableHandleScope() : scope() {}

  inline static int NumberOfHandles() {
    return v8::HandleScope::NumberOfHandles();
  }

  template&lt;typename T&gt;
  inline v8::Local&lt;T&gt; Escape(v8::Local&lt;T&gt; value) {
    return scope.Close(value);
  }

 private:
  v8::HandleScope scope;
#endif

 private:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>Make it hard to create heap-allocated or illegal handle scopes by
disallowing certain operations.</p>

        </td>
        <td class="code highlight">
          <pre class="c">  EscapableHandleScope(<span class="hljs-keyword">const</span> EscapableHandleScope &amp;);
  <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> EscapableHandleScope &amp;);
  <span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">size_t</span>)</span></span>;
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>=== TryCatch =================================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-keyword">class</span> TryCatch {
  v8::TryCatch try_catch_;
  <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FatalException</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TryCatch&amp;)</span></span>;

 <span class="hljs-keyword">public</span>:
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &gt; NODE_0_12_MODULE_VERSION</span>
  TryCatch() : try_catch_(v8::Isolate::GetCurrent()) {}
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">HasCaught</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> try_catch_.HasCaught(); }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">CanContinue</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> try_catch_.CanContinue(); }

  <span class="hljs-keyword">inline</span> v8::Local&lt;v8::Value&gt; ReThrow() {
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION</span>
    <span class="hljs-keyword">return</span> New(try_catch_.ReThrow());
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    <span class="hljs-keyword">return</span> try_catch_.ReThrow();
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  }

  <span class="hljs-keyword">inline</span> v8::Local&lt;v8::Value&gt; Exception() <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> try_catch_.Exception();
  }

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(V8_MAJOR_VERSION) &amp;&amp; (V8_MAJOR_VERSION &gt; 4 ||                      \
  (V8_MAJOR_VERSION == 4 &amp;&amp; defined(V8_MINOR_VERSION) &amp;&amp; V8_MINOR_VERSION &gt;= 3))</span>
  <span class="hljs-keyword">inline</span> v8::MaybeLocal&lt;v8::Value&gt; StackTrace() <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> try_catch_.StackTrace(GetCurrentContext());
  }
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">inline</span> MaybeLocal&lt;v8::Value&gt; StackTrace() <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> MaybeLocal&lt;v8::Value&gt;(try_catch_.StackTrace());
  }
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

  <span class="hljs-keyword">inline</span> v8::Local&lt;v8::Message&gt; Message() <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> try_catch_.Message();
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span><span class="hljs-params">()</span> </span>{ try_catch_.Reset(); }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetVerbose</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> value)</span> </span>{ try_catch_.SetVerbose(value); }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetCaptureMessage</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> value)</span> </span>{
    try_catch_.SetCaptureMessage(value);
  }
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>============ =================================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-comment">/* node 0.12  */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &gt;= NODE_0_12_MODULE_VERSION</span>
  <span class="hljs-function"><span class="hljs-keyword">inline</span>
  <span class="hljs-keyword">void</span> <span class="hljs-title">SetCounterFunction</span><span class="hljs-params">(v8::CounterLookupCallback cb)</span> </span>{
    v8::Isolate::GetCurrent()-&gt;SetCounterFunction(cb);
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span>
  <span class="hljs-keyword">void</span> <span class="hljs-title">SetCreateHistogramFunction</span><span class="hljs-params">(v8::CreateHistogramCallback cb)</span> </span>{
    v8::Isolate::GetCurrent()-&gt;SetCreateHistogramFunction(cb);
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span>
  <span class="hljs-keyword">void</span> <span class="hljs-title">SetAddHistogramSampleFunction</span><span class="hljs-params">(v8::AddHistogramSampleCallback cb)</span> </span>{
    v8::Isolate::GetCurrent()-&gt;SetAddHistogramSampleFunction(cb);
  }

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(V8_MAJOR_VERSION) &amp;&amp; (V8_MAJOR_VERSION &gt; 4 ||                      \
  (V8_MAJOR_VERSION == 4 &amp;&amp; defined(V8_MINOR_VERSION) &amp;&amp; V8_MINOR_VERSION &gt;= 3))</span>
  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IdleNotification</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idle_time_in_ms)</span> </span>{
    <span class="hljs-keyword">return</span> v8::Isolate::GetCurrent()-&gt;IdleNotificationDeadline(
        idle_time_in_ms * <span class="hljs-number">0.001</span>);
  }
<span class="hljs-meta"># <span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IdleNotification</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idle_time_in_ms)</span> </span>{
    <span class="hljs-keyword">return</span> v8::Isolate::GetCurrent()-&gt;IdleNotification(idle_time_in_ms);
  }
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LowMemoryNotification</span><span class="hljs-params">()</span> </span>{
    v8::Isolate::GetCurrent()-&gt;LowMemoryNotification();
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ContextDisposedNotification</span><span class="hljs-params">()</span> </span>{
    v8::Isolate::GetCurrent()-&gt;ContextDisposedNotification();
  }
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-function"><span class="hljs-keyword">inline</span>
  <span class="hljs-keyword">void</span> <span class="hljs-title">SetCounterFunction</span><span class="hljs-params">(v8::CounterLookupCallback cb)</span> </span>{
    v8::V8::SetCounterFunction(cb);
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span>
  <span class="hljs-keyword">void</span> <span class="hljs-title">SetCreateHistogramFunction</span><span class="hljs-params">(v8::CreateHistogramCallback cb)</span> </span>{
    v8::V8::SetCreateHistogramFunction(cb);
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span>
  <span class="hljs-keyword">void</span> <span class="hljs-title">SetAddHistogramSampleFunction</span><span class="hljs-params">(v8::AddHistogramSampleCallback cb)</span> </span>{
    v8::V8::SetAddHistogramSampleFunction(cb);
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IdleNotification</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idle_time_in_ms)</span> </span>{
    <span class="hljs-keyword">return</span> v8::V8::IdleNotification(idle_time_in_ms);
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LowMemoryNotification</span><span class="hljs-params">()</span> </span>{
    v8::V8::LowMemoryNotification();
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ContextDisposedNotification</span><span class="hljs-params">()</span> </span>{
    v8::V8::ContextDisposedNotification();
  }
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION)  <span class="hljs-comment">// Node 0.12</span></span>
  <span class="hljs-keyword">inline</span> v8::Local&lt;v8::Primitive&gt; Undefined() {
<span class="hljs-meta"># <span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION</span>
    EscapableHandleScope scope;
    <span class="hljs-keyword">return</span> scope.Escape(New(v8::Undefined(v8::Isolate::GetCurrent())));
<span class="hljs-meta"># <span class="hljs-meta-keyword">else</span></span>
    <span class="hljs-keyword">return</span> v8::Undefined(v8::Isolate::GetCurrent());
<span class="hljs-meta"># <span class="hljs-meta-keyword">endif</span></span>
  }

  <span class="hljs-keyword">inline</span> v8::Local&lt;v8::Primitive&gt; Null() {
<span class="hljs-meta"># <span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION</span>
    EscapableHandleScope scope;
    <span class="hljs-keyword">return</span> scope.Escape(New(v8::Null(v8::Isolate::GetCurrent())));
<span class="hljs-meta"># <span class="hljs-meta-keyword">else</span></span>
    <span class="hljs-keyword">return</span> v8::Null(v8::Isolate::GetCurrent());
<span class="hljs-meta"># <span class="hljs-meta-keyword">endif</span></span>
  }

  <span class="hljs-keyword">inline</span> v8::Local&lt;v8::Boolean&gt; True() {
<span class="hljs-meta"># <span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION</span>
    EscapableHandleScope scope;
    <span class="hljs-keyword">return</span> scope.Escape(New(v8::True(v8::Isolate::GetCurrent())));
<span class="hljs-meta"># <span class="hljs-meta-keyword">else</span></span>
    <span class="hljs-keyword">return</span> v8::True(v8::Isolate::GetCurrent());
<span class="hljs-meta"># <span class="hljs-meta-keyword">endif</span></span>
  }

  <span class="hljs-keyword">inline</span> v8::Local&lt;v8::Boolean&gt; False() {
<span class="hljs-meta"># <span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION</span>
    EscapableHandleScope scope;
    <span class="hljs-keyword">return</span> scope.Escape(New(v8::False(v8::Isolate::GetCurrent())));
<span class="hljs-meta"># <span class="hljs-meta-keyword">else</span></span>
    <span class="hljs-keyword">return</span> v8::False(v8::Isolate::GetCurrent());
<span class="hljs-meta"># <span class="hljs-meta-keyword">endif</span></span>
  }

  <span class="hljs-keyword">inline</span> v8::Local&lt;v8::String&gt; EmptyString() {
    <span class="hljs-keyword">return</span> v8::String::Empty(v8::Isolate::GetCurrent());
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">AdjustExternalMemory</span><span class="hljs-params">(<span class="hljs-keyword">int</span> bc)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(
        v8::Isolate::GetCurrent()-&gt;AdjustAmountOfExternalAllocatedMemory(bc));
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetTemplate</span><span class="hljs-params">(
      v8::Local&lt;v8::Template&gt; templ
    , <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name
    , v8::Local&lt;v8::Data&gt; value)</span> </span>{
    templ-&gt;Set(v8::Isolate::GetCurrent(), name, value);
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetTemplate</span><span class="hljs-params">(
      v8::Local&lt;v8::Template&gt; templ
    , v8::Local&lt;v8::String&gt; name
    , v8::Local&lt;v8::Data&gt; value
    , v8::PropertyAttribute attributes)</span> </span>{
    templ-&gt;Set(name, value, attributes);
  }

  <span class="hljs-keyword">inline</span> v8::Local&lt;v8::Context&gt; GetCurrentContext() {
    <span class="hljs-keyword">return</span> v8::Isolate::GetCurrent()-&gt;GetCurrentContext();
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>* <span class="hljs-title">GetInternalFieldPointer</span><span class="hljs-params">(
      v8::Local&lt;v8::Object&gt; object
    , <span class="hljs-keyword">int</span> index)</span> </span>{
    <span class="hljs-keyword">return</span> object-&gt;GetAlignedPointerFromInternalField(index);
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetInternalFieldPointer</span><span class="hljs-params">(
      v8::Local&lt;v8::Object&gt; object
    , <span class="hljs-keyword">int</span> index
    , <span class="hljs-keyword">void</span>* value)</span> </span>{
    object-&gt;SetAlignedPointerInInternalField(index, value);
  }

<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> NAN_GC_CALLBACK(name)                                                 \
    void name(v8::Isolate *isolate, v8::GCType type, v8::GCCallbackFlags flags)</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &lt;= NODE_4_0_MODULE_VERSION</span>
  <span class="hljs-keyword">typedef</span> v8::Isolate::GCEpilogueCallback GCEpilogueCallback;
  <span class="hljs-keyword">typedef</span> v8::Isolate::GCPrologueCallback GCPrologueCallback;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  <span class="hljs-keyword">typedef</span> v8::Isolate::GCCallback GCEpilogueCallback;
  <span class="hljs-keyword">typedef</span> v8::Isolate::GCCallback GCPrologueCallback;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddGCEpilogueCallback</span><span class="hljs-params">(
      GCEpilogueCallback callback
    , v8::GCType gc_type_filter = v8::kGCTypeAll)</span> </span>{
    v8::Isolate::GetCurrent()-&gt;AddGCEpilogueCallback(callback, gc_type_filter);
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RemoveGCEpilogueCallback</span><span class="hljs-params">(
      GCEpilogueCallback callback)</span> </span>{
    v8::Isolate::GetCurrent()-&gt;RemoveGCEpilogueCallback(callback);
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddGCPrologueCallback</span><span class="hljs-params">(
      GCPrologueCallback callback
    , v8::GCType gc_type_filter = v8::kGCTypeAll)</span> </span>{
    v8::Isolate::GetCurrent()-&gt;AddGCPrologueCallback(callback, gc_type_filter);
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RemoveGCPrologueCallback</span><span class="hljs-params">(
      GCPrologueCallback callback)</span> </span>{
    v8::Isolate::GetCurrent()-&gt;RemoveGCPrologueCallback(callback);
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetHeapStatistics</span><span class="hljs-params">(
      v8::HeapStatistics *heap_statistics)</span> </span>{
    v8::Isolate::GetCurrent()-&gt;GetHeapStatistics(heap_statistics);
  }

<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> X(NAME)                                                               \
    inline v8::Local<span class="hljs-meta-string">&lt;v8::Value&gt; NAME(const char *msg) {                    \</span></span>
      EscapableHandleScope scope;                                              \
      <span class="hljs-keyword">return</span> scope.Escape(v8::Exception::NAME(New(msg).ToLocalChecked()));     \
    }                                                                          \
                                                                               \
    <span class="hljs-keyword">inline</span>                                                                 \
    v8::Local&lt;v8::Value&gt; NAME(v8::Local&lt;v8::String&gt; msg) {                     \
      <span class="hljs-keyword">return</span> v8::Exception::NAME(msg);                                         \
    }                                                                          \
                                                                               \
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> Throw ## NAME(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *msg) {                           \
      HandleScope scope;                                                       \
      v8::Isolate::GetCurrent()-&gt;ThrowException(                               \
          v8::Exception::NAME(New(msg).ToLocalChecked()));                     \
    }                                                                          \
                                                                               \
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> Throw ## NAME(v8::Local&lt;v8::String&gt; msg) {                 \
      HandleScope scope;                                                       \
      v8::Isolate::GetCurrent()-&gt;ThrowException(                               \
          v8::Exception::NAME(msg));                                           \
    }

  X(Error)
  X(RangeError)
  X(ReferenceError)
  X(SyntaxError)
  X(TypeError)

<span class="hljs-meta"># <span class="hljs-meta-keyword">undef</span> X</span>

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ThrowError</span><span class="hljs-params">(v8::Local&lt;v8::Value&gt; error)</span> </span>{
    v8::Isolate::GetCurrent()-&gt;ThrowException(error);
  }

  <span class="hljs-keyword">inline</span> MaybeLocal&lt;v8::Object&gt; NewBuffer(
      <span class="hljs-keyword">char</span> *data
    , <span class="hljs-keyword">size_t</span> length
#<span class="hljs-keyword">if</span> NODE_MODULE_VERSION &gt; IOJS_2_0_MODULE_VERSION
    , node::Buffer::FreeCallback callback
#<span class="hljs-keyword">else</span>
    , node::smalloc::FreeCallback callback
#endif
    , <span class="hljs-keyword">void</span> *hint
  ) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>arbitrary buffer lengths requires
NODE_MODULE_VERSION &gt;= IOJS_3_0_MODULE_VERSION</p>

        </td>
        <td class="code highlight">
          <pre class="c">    assert(length &lt;= imp::kMaxLength &amp;&amp; <span class="hljs-string">"too large buffer"</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &gt; IOJS_2_0_MODULE_VERSION</span>
    <span class="hljs-keyword">return</span> node::Buffer::New(
        v8::Isolate::GetCurrent(), data, length, callback, hint);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    <span class="hljs-keyword">return</span> MaybeLocal&lt;v8::Object&gt;(node::Buffer::New(
        v8::Isolate::GetCurrent(), data, length, callback, hint));
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  }

  <span class="hljs-keyword">inline</span> MaybeLocal&lt;v8::Object&gt; CopyBuffer(
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *data
    , <span class="hljs-keyword">uint32_t</span> size
  ) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>arbitrary buffer lengths requires
NODE_MODULE_VERSION &gt;= IOJS_3_0_MODULE_VERSION</p>

        </td>
        <td class="code highlight">
          <pre class="c">    assert(size &lt;= imp::kMaxLength &amp;&amp; <span class="hljs-string">"too large buffer"</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &gt; IOJS_2_0_MODULE_VERSION</span>
    <span class="hljs-keyword">return</span> node::Buffer::Copy(
        v8::Isolate::GetCurrent(), data, size);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    <span class="hljs-keyword">return</span> MaybeLocal&lt;v8::Object&gt;(node::Buffer::New(
        v8::Isolate::GetCurrent(), data, size));
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  }

  <span class="hljs-keyword">inline</span> MaybeLocal&lt;v8::Object&gt; NewBuffer(<span class="hljs-keyword">uint32_t</span> size) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>arbitrary buffer lengths requires
NODE_MODULE_VERSION &gt;= IOJS_3_0_MODULE_VERSION</p>

        </td>
        <td class="code highlight">
          <pre class="c">    assert(size &lt;= imp::kMaxLength &amp;&amp; <span class="hljs-string">"too large buffer"</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &gt; IOJS_2_0_MODULE_VERSION</span>
    <span class="hljs-keyword">return</span> node::Buffer::New(
        v8::Isolate::GetCurrent(), size);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    <span class="hljs-keyword">return</span> MaybeLocal&lt;v8::Object&gt;(node::Buffer::New(
        v8::Isolate::GetCurrent(), size));
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  }

  <span class="hljs-keyword">inline</span> MaybeLocal&lt;v8::Object&gt; NewBuffer(
      <span class="hljs-keyword">char</span>* data
    , <span class="hljs-keyword">uint32_t</span> size
  ) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>arbitrary buffer lengths requires
NODE_MODULE_VERSION &gt;= IOJS_3_0_MODULE_VERSION</p>

        </td>
        <td class="code highlight">
          <pre class="c">    assert(size &lt;= imp::kMaxLength &amp;&amp; "too large buffer");
#if NODE_MODULE_VERSION &gt; IOJS_2_0_MODULE_VERSION
    return node::Buffer::New(v8::Isolate::GetCurrent(), data, size);
#else
    return MaybeLocal&lt;v8::Object&gt;(
        node::Buffer::Use(v8::Isolate::GetCurrent(), data, size));
#endif
  }

#if defined(V8_MAJOR_VERSION) &amp;&amp; (V8_MAJOR_VERSION &gt; 4 ||                      \
  (V8_MAJOR_VERSION == 4 &amp;&amp; defined(V8_MINOR_VERSION) &amp;&amp; V8_MINOR_VERSION &gt;= 3))
  inline MaybeLocal&lt;v8::String&gt;
  NewOneByteString(const uint8_t * value, int length = -1) {
    return v8::String::NewFromOneByte(v8::Isolate::GetCurrent(), value,
          v8::NewStringType::kNormal, length);
  }

  inline MaybeLocal&lt;BoundScript&gt; CompileScript(
      v8::Local&lt;v8::String&gt; s
    , const v8::ScriptOrigin&amp; origin
  ) {
    v8::ScriptCompiler::Source source(s, origin);
    return v8::ScriptCompiler::Compile(GetCurrentContext(), &amp;source);
  }

  inline MaybeLocal&lt;BoundScript&gt; CompileScript(
      v8::Local&lt;v8::String&gt; s
  ) {
    v8::ScriptCompiler::Source source(s);
    return v8::ScriptCompiler::Compile(GetCurrentContext(), &amp;source);
  }

  inline MaybeLocal&lt;v8::Value&gt; RunScript(
      v8::Local&lt;UnboundScript&gt; script
  ) {
    return script-&gt;BindToCurrentContext()-&gt;Run(GetCurrentContext());
  }

  inline MaybeLocal&lt;v8::Value&gt; RunScript(
      v8::Local&lt;BoundScript&gt; script
  ) {
    return script-&gt;Run(GetCurrentContext());
  }
#else
  inline MaybeLocal&lt;v8::String&gt;
  NewOneByteString(const uint8_t * value, int length = -1) {
    return MaybeLocal&lt;v8::String&gt;(
        v8::String::NewFromOneByte(
            v8::Isolate::GetCurrent()
          , value
          , v8::String::kNormalString, length));
  }

  inline MaybeLocal&lt;BoundScript&gt; CompileScript(
      v8::Local&lt;v8::String&gt; s
    , const v8::ScriptOrigin&amp; origin
  ) {
    v8::ScriptCompiler::Source source(s, origin);
    return MaybeLocal&lt;BoundScript&gt;(
        v8::ScriptCompiler::Compile(v8::Isolate::GetCurrent(), &amp;source));
  }

  inline MaybeLocal&lt;BoundScript&gt; CompileScript(
      v8::Local&lt;v8::String&gt; s
  ) {
    v8::ScriptCompiler::Source source(s);
    return MaybeLocal&lt;BoundScript&gt;(
        v8::ScriptCompiler::Compile(v8::Isolate::GetCurrent(), &amp;source));
  }

  inline MaybeLocal&lt;v8::Value&gt; RunScript(
      v8::Local&lt;UnboundScript&gt; script
  ) {
    return MaybeLocal&lt;v8::Value&gt;(script-&gt;BindToCurrentContext()-&gt;Run());
  }

  inline MaybeLocal&lt;v8::Value&gt; RunScript(
      v8::Local&lt;BoundScript&gt; script
  ) {
    return MaybeLocal&lt;v8::Value&gt;(script-&gt;Run());
  }
#endif

  inline v8::Local&lt;v8::Value&gt; MakeCallback(
      v8::Local&lt;v8::Object&gt; target
    , v8::Local&lt;v8::Function&gt; func
    , int argc
    , v8::Local&lt;v8::Value&gt;* argv) {
#if NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION
    return New(node::MakeCallback(
        v8::Isolate::GetCurrent(), target, func, argc, argv));
#else
    return node::MakeCallback(
        v8::Isolate::GetCurrent(), target, func, argc, argv);
#endif
  }

  inline v8::Local&lt;v8::Value&gt; MakeCallback(
      v8::Local&lt;v8::Object&gt; target
    , v8::Local&lt;v8::String&gt; symbol
    , int argc
    , v8::Local&lt;v8::Value&gt;* argv) {
#if NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION
    return New(node::MakeCallback(
        v8::Isolate::GetCurrent(), target, symbol, argc, argv));
#else
    return node::MakeCallback(
        v8::Isolate::GetCurrent(), target, symbol, argc, argv);
#endif
  }

  inline v8::Local&lt;v8::Value&gt; MakeCallback(
      v8::Local&lt;v8::Object&gt; target
    , const char* method
    , int argc
    , v8::Local&lt;v8::Value&gt;* argv) {
#if NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION
    return New(node::MakeCallback(
        v8::Isolate::GetCurrent(), target, method, argc, argv));
#else
    return node::MakeCallback(
        v8::Isolate::GetCurrent(), target, method, argc, argv);
#endif
  }

  inline void FatalException(const TryCatch&amp; try_catch) {
    node::FatalException(v8::Isolate::GetCurrent(), try_catch.try_catch_);
  }

  inline v8::Local&lt;v8::Value&gt; ErrnoException(
          int errorno
       ,  const char* syscall = NULL
       ,  const char* message = NULL
       ,  const char* path = NULL) {
    return node::ErrnoException(v8::Isolate::GetCurrent(), errorno, syscall,
            message, path);
  }

  NAN_DEPRECATED inline v8::Local&lt;v8::Value&gt; NanErrnoException(
          int errorno
       ,  const char* syscall = NULL
       ,  const char* message = NULL
       ,  const char* path = NULL) {
    return ErrnoException(errorno, syscall, message, path);
  }

  template&lt;typename T&gt;
  inline void SetIsolateData(
      v8::Isolate *isolate
    , T *data
  ) {
      isolate-&gt;SetData(0, data);
  }

  template&lt;typename T&gt;
  inline T *GetIsolateData(
      v8::Isolate *isolate
  ) {
      return static_cast&lt;T*&gt;(isolate-&gt;GetData(0));
  }

class Utf8String {
 public:
  inline explicit Utf8String(v8::Local&lt;v8::Value&gt; from) :
      length_(0), str_(str_st_) {
    if (!from.IsEmpty()) {
      v8::Local&lt;v8::String&gt; string = from-&gt;ToString();
      if (!string.IsEmpty()) {
        size_t len = 3 * string-&gt;Length() + 1;
        assert(len &lt;= INT_MAX);
        if (len &gt; sizeof (str_st_)) {
          str_ = static_cast&lt;char*&gt;(malloc(len));
          assert(str_ != 0);
        }
        const int flags =
            v8::String::NO_NULL_TERMINATION | imp::kReplaceInvalidUtf8;
        length_ = string-&gt;WriteUtf8(str_, static_cast&lt;int&gt;(len), 0, flags);
        str_[length_] = '\0';
      }
    }
  }

  inline int length() const {
    return length_;
  }

  inline char* operator*() { return str_; }
  inline const char* operator*() const { return str_; }

  inline ~Utf8String() {
    if (str_ != str_st_) {
      free(str_);
    }
  }

 private:
  NAN_DISALLOW_ASSIGN_COPY_MOVE(Utf8String)

  int length_;
  char *str_;
  char str_st_[1024];
};

#else  // Node 0.8 and 0.10
  inline v8::Local&lt;v8::Primitive&gt; Undefined() {
    EscapableHandleScope scope;
    return scope.Escape(New(v8::Undefined()));
  }

  inline v8::Local&lt;v8::Primitive&gt; Null() {
    EscapableHandleScope scope;
    return scope.Escape(New(v8::Null()));
  }

  inline v8::Local&lt;v8::Boolean&gt; True() {
    EscapableHandleScope scope;
    return scope.Escape(New(v8::True()));
  }

  inline v8::Local&lt;v8::Boolean&gt; False() {
    EscapableHandleScope scope;
    return scope.Escape(New(v8::False()));
  }

  inline v8::Local&lt;v8::String&gt; EmptyString() {
    return v8::String::Empty();
  }

  inline int AdjustExternalMemory(int bc) {
    return static_cast&lt;int&gt;(v8::V8::AdjustAmountOfExternalAllocatedMemory(bc));
  }

  inline void SetTemplate(
      v8::Local&lt;v8::Template&gt; templ
    , const char *name
    , v8::Local&lt;v8::Data&gt; value) {
    templ-&gt;Set(name, value);
  }

  inline void SetTemplate(
      v8::Local&lt;v8::Template&gt; templ
    , v8::Local&lt;v8::String&gt; name
    , v8::Local&lt;v8::Data&gt; value
    , v8::PropertyAttribute attributes) {
    templ-&gt;Set(name, value, attributes);
  }

  inline v8::Local&lt;v8::Context&gt; GetCurrentContext() {
    return v8::Context::GetCurrent();
  }

  inline void* GetInternalFieldPointer(
      v8::Local&lt;v8::Object&gt; object
    , int index) {
    return object-&gt;GetPointerFromInternalField(index);
  }

  inline void SetInternalFieldPointer(
      v8::Local&lt;v8::Object&gt; object
    , int index
    , void* value) {
    object-&gt;SetPointerInInternalField(index, value);
  }

# define NAN_GC_CALLBACK(name)                                                 \
    void name(v8::GCType type, v8::GCCallbackFlags flags)

  inline void AddGCEpilogueCallback(
    v8::GCEpilogueCallback callback
  , v8::GCType gc_type_filter = v8::kGCTypeAll) {
    v8::V8::AddGCEpilogueCallback(callback, gc_type_filter);
  }
  inline void RemoveGCEpilogueCallback(
    v8::GCEpilogueCallback callback) {
    v8::V8::RemoveGCEpilogueCallback(callback);
  }
  inline void AddGCPrologueCallback(
    v8::GCPrologueCallback callback
  , v8::GCType gc_type_filter = v8::kGCTypeAll) {
    v8::V8::AddGCPrologueCallback(callback, gc_type_filter);
  }
  inline void RemoveGCPrologueCallback(
    v8::GCPrologueCallback callback) {
    v8::V8::RemoveGCPrologueCallback(callback);
  }
  inline void GetHeapStatistics(
    v8::HeapStatistics *heap_statistics) {
    v8::V8::GetHeapStatistics(heap_statistics);
  }

# define X(NAME)                                                               \
    inline v8::Local&lt;v8::Value&gt; NAME(const char *msg) {                    \
      EscapableHandleScope scope;                                              \
      return scope.Escape(v8::Exception::NAME(New(msg).ToLocalChecked()));     \
    }                                                                          \
                                                                               \
    inline                                                                 \
    v8::Local&lt;v8::Value&gt; NAME(v8::Local&lt;v8::String&gt; msg) {                     \
      return v8::Exception::NAME(msg);                                         \
    }                                                                          \
                                                                               \
    inline void Throw ## NAME(const char *msg) {                           \
      HandleScope scope;                                                       \
      v8::ThrowException(v8::Exception::NAME(New(msg).ToLocalChecked()));      \
    }                                                                          \
                                                                               \
    inline                                                                 \
    void Throw ## NAME(v8::Local&lt;v8::String&gt; errmsg) {                         \
      v8::ThrowException(v8::Exception::NAME(errmsg));                         \
    }

  X(Error)
  X(RangeError)
  X(ReferenceError)
  X(SyntaxError)
  X(TypeError)

# undef X

  inline void ThrowError(v8::Local&lt;v8::Value&gt; error) {
    v8::ThrowException(error);
  }

  inline MaybeLocal&lt;v8::Object&gt; NewBuffer(
      char *data
    , size_t length
    , node::Buffer::free_callback callback
    , void *hint
  ) {
    EscapableHandleScope scope;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>arbitrary buffer lengths requires
NODE_MODULE_VERSION &gt;= IOJS_3_0_MODULE_VERSION</p>

        </td>
        <td class="code highlight">
          <pre class="c">    assert(length &lt;= imp::kMaxLength &amp;&amp; <span class="hljs-string">"too large buffer"</span>);
    <span class="hljs-keyword">return</span> MaybeLocal&lt;v8::Object&gt;(scope.Escape(
        New(node::Buffer::New(data, length, callback, hint)-&gt;handle_)));
  }

  <span class="hljs-keyword">inline</span> MaybeLocal&lt;v8::Object&gt; CopyBuffer(
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *data
    , <span class="hljs-keyword">uint32_t</span> size
  ) {
    EscapableHandleScope scope;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>arbitrary buffer lengths requires
NODE_MODULE_VERSION &gt;= IOJS_3_0_MODULE_VERSION</p>

        </td>
        <td class="code highlight">
          <pre class="c">    assert(size &lt;= imp::kMaxLength &amp;&amp; <span class="hljs-string">"too large buffer"</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> NODE_MODULE_VERSION &gt;= NODE_0_10_MODULE_VERSION</span>
    <span class="hljs-keyword">return</span> MaybeLocal&lt;v8::Object&gt;(
        scope.Escape(New(node::Buffer::New(data, size)-&gt;handle_)));
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    <span class="hljs-keyword">return</span> MaybeLocal&lt;v8::Object&gt;(scope.Escape(
        New(node::Buffer::New(<span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(data), size)-&gt;handle_)));
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  }

  <span class="hljs-keyword">inline</span> MaybeLocal&lt;v8::Object&gt; NewBuffer(<span class="hljs-keyword">uint32_t</span> size) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<p>arbitrary buffer lengths requires
NODE_MODULE_VERSION &gt;= IOJS_3_0_MODULE_VERSION</p>

        </td>
        <td class="code highlight">
          <pre class="c">    EscapableHandleScope scope;
    assert(size &lt;= imp::kMaxLength &amp;&amp; <span class="hljs-string">"too large buffer"</span>);
    <span class="hljs-keyword">return</span> MaybeLocal&lt;v8::Object&gt;(
        scope.Escape(New(node::Buffer::New(size)-&gt;handle_)));
  }

  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FreeData</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *data, <span class="hljs-keyword">void</span> *hint)</span> </span>{
    (<span class="hljs-keyword">void</span>) hint;  <span class="hljs-comment">// unused</span>
    <span class="hljs-keyword">delete</span>[] data;
  }

  <span class="hljs-keyword">inline</span> MaybeLocal&lt;v8::Object&gt; NewBuffer(
      <span class="hljs-keyword">char</span>* data
    , <span class="hljs-keyword">uint32_t</span> size
  ) {
    EscapableHandleScope scope;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>arbitrary buffer lengths requires
NODE_MODULE_VERSION &gt;= IOJS_3_0_MODULE_VERSION</p>

        </td>
        <td class="code highlight">
          <pre class="c">    assert(size &lt;= imp::kMaxLength &amp;&amp; "too large buffer");
    return MaybeLocal&lt;v8::Object&gt;(scope.Escape(New(
        node::Buffer::New(data, size, FreeData, NULL)-&gt;handle_)));
  }

namespace imp {
inline void
widenString(std::vector&lt;uint16_t&gt; *ws, const uint8_t *s, int l) {
  size_t len = static_cast&lt;size_t&gt;(l);
  if (l &lt; 0) {
    len = strlen(reinterpret_cast&lt;const char*&gt;(s));
  }
  assert(len &lt;= INT_MAX &amp;&amp; "string too long");
  ws-&gt;resize(len);
  std::copy(s, s + len, ws-&gt;begin());  // NOLINT(build/include_what_you_use)
}
}  // end of namespace imp

  inline MaybeLocal&lt;v8::String&gt;
  NewOneByteString(const uint8_t * value, int length = -1) {
    std::vector&lt;uint16_t&gt; wideString;  // NOLINT(build/include_what_you_use)
    imp::widenString(&amp;wideString, value, length);
    return imp::Factory&lt;v8::String&gt;::return_t(v8::String::New(
        &amp;wideString.front(), static_cast&lt;int&gt;(wideString.size())));
  }

  inline MaybeLocal&lt;BoundScript&gt; CompileScript(
      v8::Local&lt;v8::String&gt; s
    , const v8::ScriptOrigin&amp; origin
  ) {
    return MaybeLocal&lt;BoundScript&gt;(
        v8::Script::Compile(s, const_cast&lt;v8::ScriptOrigin *&gt;(&amp;origin)));
  }

  inline MaybeLocal&lt;BoundScript&gt; CompileScript(
    v8::Local&lt;v8::String&gt; s
  ) {
    return MaybeLocal&lt;BoundScript&gt;(v8::Script::Compile(s));
  }

  inline
  MaybeLocal&lt;v8::Value&gt; RunScript(v8::Local&lt;v8::Script&gt; script) {
    return MaybeLocal&lt;v8::Value&gt;(script-&gt;Run());
  }

  inline v8::Local&lt;v8::Value&gt; MakeCallback(
      v8::Local&lt;v8::Object&gt; target
    , v8::Local&lt;v8::Function&gt; func
    , int argc
    , v8::Local&lt;v8::Value&gt;* argv) {
    return New(node::MakeCallback(target, func, argc, argv));
  }

  inline v8::Local&lt;v8::Value&gt; MakeCallback(
      v8::Local&lt;v8::Object&gt; target
    , v8::Local&lt;v8::String&gt; symbol
    , int argc
    , v8::Local&lt;v8::Value&gt;* argv) {
    return New(node::MakeCallback(target, symbol, argc, argv));
  }

  inline v8::Local&lt;v8::Value&gt; MakeCallback(
      v8::Local&lt;v8::Object&gt; target
    , const char* method
    , int argc
    , v8::Local&lt;v8::Value&gt;* argv) {
    return New(node::MakeCallback(target, method, argc, argv));
  }

  inline void FatalException(const TryCatch&amp; try_catch) {
    node::FatalException(const_cast&lt;v8::TryCatch &amp;&gt;(try_catch.try_catch_));
  }

  inline v8::Local&lt;v8::Value&gt; ErrnoException(
          int errorno
       ,  const char* syscall = NULL
       ,  const char* message = NULL
       ,  const char* path = NULL) {
    return node::ErrnoException(errorno, syscall, message, path);
  }

  NAN_DEPRECATED inline v8::Local&lt;v8::Value&gt; NanErrnoException(
          int errorno
       ,  const char* syscall = NULL
       ,  const char* message = NULL
       ,  const char* path = NULL) {
    return ErrnoException(errorno, syscall, message, path);
  }


  template&lt;typename T&gt;
  inline void SetIsolateData(
      v8::Isolate *isolate
    , T *data
  ) {
      isolate-&gt;SetData(data);
  }

  template&lt;typename T&gt;
  inline T *GetIsolateData(
      v8::Isolate *isolate
  ) {
      return static_cast&lt;T*&gt;(isolate-&gt;GetData());
  }

class Utf8String {
 public:
  inline explicit Utf8String(v8::Local&lt;v8::Value&gt; from) :
      length_(0), str_(str_st_) {
    if (!from.IsEmpty()) {
      v8::Local&lt;v8::String&gt; string = from-&gt;ToString();
      if (!string.IsEmpty()) {
        size_t len = 3 * string-&gt;Length() + 1;
        assert(len &lt;= INT_MAX);
        if (len &gt; sizeof (str_st_)) {
          str_ = static_cast&lt;char*&gt;(malloc(len));
          assert(str_ != 0);
        }
        const int flags =
            v8::String::NO_NULL_TERMINATION | imp::kReplaceInvalidUtf8;
        length_ = string-&gt;WriteUtf8(str_, static_cast&lt;int&gt;(len), 0, flags);
        str_[length_] = '\0';
      }
    }
  }

  inline int length() const {
    return length_;
  }

  inline char* operator*() { return str_; }
  inline const char* operator*() const { return str_; }

  inline ~Utf8String() {
    if (str_ != str_st_) {
      free(str_);
    }
  }

 private:
  NAN_DISALLOW_ASSIGN_COPY_MOVE(Utf8String)

  int length_;
  char *str_;
  char str_st_[1024];
};

#endif  // NODE_MODULE_VERSION

typedef void (*FreeCallback)(char *data, void *hint);

typedef const FunctionCallbackInfo&lt;v8::Value&gt;&amp; NAN_METHOD_ARGS_TYPE;
typedef void NAN_METHOD_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Value&gt;&amp; NAN_GETTER_ARGS_TYPE;
typedef void NAN_GETTER_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;void&gt;&amp; NAN_SETTER_ARGS_TYPE;
typedef void NAN_SETTER_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Value&gt;&amp;
    NAN_PROPERTY_GETTER_ARGS_TYPE;
typedef void NAN_PROPERTY_GETTER_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Value&gt;&amp;
    NAN_PROPERTY_SETTER_ARGS_TYPE;
typedef void NAN_PROPERTY_SETTER_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Array&gt;&amp;
    NAN_PROPERTY_ENUMERATOR_ARGS_TYPE;
typedef void NAN_PROPERTY_ENUMERATOR_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Boolean&gt;&amp;
    NAN_PROPERTY_DELETER_ARGS_TYPE;
typedef void NAN_PROPERTY_DELETER_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Integer&gt;&amp;
    NAN_PROPERTY_QUERY_ARGS_TYPE;
typedef void NAN_PROPERTY_QUERY_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Value&gt;&amp; NAN_INDEX_GETTER_ARGS_TYPE;
typedef void NAN_INDEX_GETTER_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Value&gt;&amp; NAN_INDEX_SETTER_ARGS_TYPE;
typedef void NAN_INDEX_SETTER_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Array&gt;&amp;
    NAN_INDEX_ENUMERATOR_ARGS_TYPE;
typedef void NAN_INDEX_ENUMERATOR_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Boolean&gt;&amp;
    NAN_INDEX_DELETER_ARGS_TYPE;
typedef void NAN_INDEX_DELETER_RETURN_TYPE;

typedef const PropertyCallbackInfo&lt;v8::Integer&gt;&amp;
    NAN_INDEX_QUERY_ARGS_TYPE;
typedef void NAN_INDEX_QUERY_RETURN_TYPE;

#define NAN_METHOD(name)                                                       \
    Nan::NAN_METHOD_RETURN_TYPE name(Nan::NAN_METHOD_ARGS_TYPE info)
#define NAN_GETTER(name)                                                       \
    Nan::NAN_GETTER_RETURN_TYPE name(                                          \
        v8::Local&lt;v8::String&gt; property                                         \
      , Nan::NAN_GETTER_ARGS_TYPE info)
#define NAN_SETTER(name)                                                       \
    Nan::NAN_SETTER_RETURN_TYPE name(                                          \
        v8::Local&lt;v8::String&gt; property                                         \
      , v8::Local&lt;v8::Value&gt; value                                             \
      , Nan::NAN_SETTER_ARGS_TYPE info)
#define NAN_PROPERTY_GETTER(name)                                              \
    Nan::NAN_PROPERTY_GETTER_RETURN_TYPE name(                                 \
        v8::Local&lt;v8::String&gt; property                                         \
      , Nan::NAN_PROPERTY_GETTER_ARGS_TYPE info)
#define NAN_PROPERTY_SETTER(name)                                              \
    Nan::NAN_PROPERTY_SETTER_RETURN_TYPE name(                                 \
        v8::Local&lt;v8::String&gt; property                                         \
      , v8::Local&lt;v8::Value&gt; value                                             \
      , Nan::NAN_PROPERTY_SETTER_ARGS_TYPE info)
#define NAN_PROPERTY_ENUMERATOR(name)                                          \
    Nan::NAN_PROPERTY_ENUMERATOR_RETURN_TYPE name(                             \
        Nan::NAN_PROPERTY_ENUMERATOR_ARGS_TYPE info)
#define NAN_PROPERTY_DELETER(name)                                             \
    Nan::NAN_PROPERTY_DELETER_RETURN_TYPE name(                                \
        v8::Local&lt;v8::String&gt; property                                         \
      , Nan::NAN_PROPERTY_DELETER_ARGS_TYPE info)
#define NAN_PROPERTY_QUERY(name)                                               \
    Nan::NAN_PROPERTY_QUERY_RETURN_TYPE name(                                  \
        v8::Local&lt;v8::String&gt; property                                         \
      , Nan::NAN_PROPERTY_QUERY_ARGS_TYPE info)
# define NAN_INDEX_GETTER(name)                                                \
    Nan::NAN_INDEX_GETTER_RETURN_TYPE name(                                    \
        uint32_t index                                                         \
      , Nan::NAN_INDEX_GETTER_ARGS_TYPE info)
#define NAN_INDEX_SETTER(name)                                                 \
    Nan::NAN_INDEX_SETTER_RETURN_TYPE name(                                    \
        uint32_t index                                                         \
      , v8::Local&lt;v8::Value&gt; value                                             \
      , Nan::NAN_INDEX_SETTER_ARGS_TYPE info)
#define NAN_INDEX_ENUMERATOR(name)                                             \
    Nan::NAN_INDEX_ENUMERATOR_RETURN_TYPE                                      \
    name(Nan::NAN_INDEX_ENUMERATOR_ARGS_TYPE info)
#define NAN_INDEX_DELETER(name)                                                \
    Nan::NAN_INDEX_DELETER_RETURN_TYPE name(                                   \
        uint32_t index                                                         \
      , Nan::NAN_INDEX_DELETER_ARGS_TYPE info)
#define NAN_INDEX_QUERY(name)                                                  \
    Nan::NAN_INDEX_QUERY_RETURN_TYPE name(                                     \
        uint32_t index                                                         \
      , Nan::NAN_INDEX_QUERY_ARGS_TYPE info)

class Callback {
 public:
  Callback() {
    HandleScope scope;
    v8::Local&lt;v8::Object&gt; obj = New&lt;v8::Object&gt;();
    handle.Reset(obj);
  }

  explicit Callback(const v8::Local&lt;v8::Function&gt; &amp;fn) {
    HandleScope scope;
    v8::Local&lt;v8::Object&gt; obj = New&lt;v8::Object&gt;();
    handle.Reset(obj);
    SetFunction(fn);
  }

  ~Callback() {
    if (handle.IsEmpty()) return;
    handle.Reset();
  }

  bool operator==(const Callback &amp;other) const {
    HandleScope scope;
    v8::Local&lt;v8::Value&gt; a = New(handle)-&gt;Get(kCallbackIndex);
    v8::Local&lt;v8::Value&gt; b = New(other.handle)-&gt;Get(kCallbackIndex);
    return a-&gt;StrictEquals(b);
  }

  bool operator!=(const Callback &amp;other) const {
    return !this-&gt;operator==(other);
  }

  inline
  v8::Local&lt;v8::Function&gt; operator*() const { return this-&gt;GetFunction(); }

  inline v8::Local&lt;v8::Value&gt; operator()(
      v8::Local&lt;v8::Object&gt; target
    , int argc = 0
    , v8::Local&lt;v8::Value&gt; argv[] = 0) const {
    return this-&gt;Call(target, argc, argv);
  }

  inline v8::Local&lt;v8::Value&gt; operator()(
      int argc = 0
    , v8::Local&lt;v8::Value&gt; argv[] = 0) const {
    return this-&gt;Call(argc, argv);
  }

  inline void SetFunction(const v8::Local&lt;v8::Function&gt; &amp;fn) {
    HandleScope scope;
    Set(New(handle), kCallbackIndex, fn);
  }

  inline v8::Local&lt;v8::Function&gt; GetFunction() const {
    EscapableHandleScope scope;
    return scope.Escape(New(handle)-&gt;Get(kCallbackIndex)
        .As&lt;v8::Function&gt;());
  }

  inline bool IsEmpty() const {
    HandleScope scope;
    return New(handle)-&gt;Get(kCallbackIndex)-&gt;IsUndefined();
  }

  inline v8::Local&lt;v8::Value&gt;
  Call(v8::Local&lt;v8::Object&gt; target
     , int argc
     , v8::Local&lt;v8::Value&gt; argv[]) const {
#if (NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION)
    v8::Isolate *isolate = v8::Isolate::GetCurrent();
    return Call_(isolate, target, argc, argv);
#else
    return Call_(target, argc, argv);
#endif
  }

  inline v8::Local&lt;v8::Value&gt;
  Call(int argc, v8::Local&lt;v8::Value&gt; argv[]) const {
#if (NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION)
    v8::Isolate *isolate = v8::Isolate::GetCurrent();
    return Call_(isolate, isolate-&gt;GetCurrentContext()-&gt;Global(), argc, argv);
#else
    return Call_(v8::Context::GetCurrent()-&gt;Global(), argc, argv);
#endif
  }

 private:
  NAN_DISALLOW_ASSIGN_COPY_MOVE(Callback)
  Persistent&lt;v8::Object&gt; handle;
  static const uint32_t kCallbackIndex = 0;

#if (NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION)
  v8::Local&lt;v8::Value&gt; Call_(v8::Isolate *isolate
                           , v8::Local&lt;v8::Object&gt; target
                           , int argc
                           , v8::Local&lt;v8::Value&gt; argv[]) const {
    EscapableHandleScope scope;

    v8::Local&lt;v8::Function&gt; callback = New(handle)-&gt;
        Get(kCallbackIndex).As&lt;v8::Function&gt;();
# if NODE_MODULE_VERSION &lt; IOJS_3_0_MODULE_VERSION
    return scope.Escape(New(node::MakeCallback(
        isolate
      , target
      , callback
      , argc
      , argv
    )));
# else
    return scope.Escape(node::MakeCallback(
        isolate
      , target
      , callback
      , argc
      , argv
    ));
# endif
  }
#else
  v8::Local&lt;v8::Value&gt; Call_(v8::Local&lt;v8::Object&gt; target
                           , int argc
                           , v8::Local&lt;v8::Value&gt; argv[]) const {
    EscapableHandleScope scope;

    v8::Local&lt;v8::Function&gt; callback = New(handle)-&gt;
        Get(kCallbackIndex).As&lt;v8::Function&gt;();
    return scope.Escape(New(node::MakeCallback(
        target
      , callback
      , argc
      , argv
    )));
  }
#endif
};

/* abstract */ class AsyncWorker {
 public:
  explicit AsyncWorker(Callback *callback_)
      : callback(callback_), errmsg_(NULL) {
    request.data = this;

    HandleScope scope;
    v8::Local&lt;v8::Object&gt; obj = New&lt;v8::Object&gt;();
    persistentHandle.Reset(obj);
  }

  virtual ~AsyncWorker() {
    HandleScope scope;

    if (!persistentHandle.IsEmpty())
      persistentHandle.Reset();
    delete callback;
    delete[] errmsg_;
  }

  virtual void WorkComplete() {
    HandleScope scope;

    if (errmsg_ == NULL)
      HandleOKCallback();
    else
      HandleErrorCallback();
    delete callback;
    callback = NULL;
  }

  inline void SaveToPersistent(
      const char *key, const v8::Local&lt;v8::Value&gt; &amp;value) {
    HandleScope scope;
    New(persistentHandle)-&gt;Set(New(key).ToLocalChecked(), value);
  }

  inline void SaveToPersistent(
      const v8::Local&lt;v8::String&gt; &amp;key, const v8::Local&lt;v8::Value&gt; &amp;value) {
    HandleScope scope;
    New(persistentHandle)-&gt;Set(key, value);
  }

  inline void SaveToPersistent(
      uint32_t index, const v8::Local&lt;v8::Value&gt; &amp;value) {
    HandleScope scope;
    New(persistentHandle)-&gt;Set(index, value);
  }

  inline v8::Local&lt;v8::Value&gt; GetFromPersistent(const char *key) const {
    EscapableHandleScope scope;
    return scope.Escape(
        New(persistentHandle)-&gt;Get(New(key).ToLocalChecked()));
  }

  inline v8::Local&lt;v8::Value&gt;
  GetFromPersistent(const v8::Local&lt;v8::String&gt; &amp;key) const {
    EscapableHandleScope scope;
    return scope.Escape(New(persistentHandle)-&gt;Get(key));
  }

  inline v8::Local&lt;v8::Value&gt; GetFromPersistent(uint32_t index) const {
    EscapableHandleScope scope;
    return scope.Escape(New(persistentHandle)-&gt;Get(index));
  }

  virtual void Execute() = 0;

  uv_work_t request;

  virtual void Destroy() {
      delete this;
  }

 protected:
  Persistent&lt;v8::Object&gt; persistentHandle;
  Callback *callback;

  virtual void HandleOKCallback() {
    callback-&gt;Call(0, NULL);
  }

  virtual void HandleErrorCallback() {
    HandleScope scope;

    v8::Local&lt;v8::Value&gt; argv[] = {
      v8::Exception::Error(New&lt;v8::String&gt;(ErrorMessage()).ToLocalChecked())
    };
    callback-&gt;Call(1, argv);
  }

  void SetErrorMessage(const char *msg) {
    delete[] errmsg_;

    size_t size = strlen(msg) + 1;
    errmsg_ = new char[size];
    memcpy(errmsg_, msg, size);
  }

  const char* ErrorMessage() const {
    return errmsg_;
  }

 private:
  NAN_DISALLOW_ASSIGN_COPY_MOVE(AsyncWorker)
  char *errmsg_;
};

/* abstract */ class AsyncProgressWorker : public AsyncWorker {
 public:
  explicit AsyncProgressWorker(Callback *callback_)
      : AsyncWorker(callback_), asyncdata_(NULL), asyncsize_(0) {
    async = new uv_async_t;
    uv_async_init(
        uv_default_loop()
      , async
      , AsyncProgress_
    );
    async-&gt;data = this;

    uv_mutex_init(&amp;async_lock);
  }

  virtual ~AsyncProgressWorker() {
    uv_mutex_destroy(&amp;async_lock);

    delete[] asyncdata_;
  }

  void WorkProgress() {
    uv_mutex_lock(&amp;async_lock);
    char *data = asyncdata_;
    size_t size = asyncsize_;
    asyncdata_ = NULL;
    uv_mutex_unlock(&amp;async_lock);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<p>Dont send progress events after we've already completed.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    <span class="hljs-keyword">if</span> (callback) {
        HandleProgressCallback(data, size);
    }
    <span class="hljs-keyword">delete</span>[] data;
  }

  <span class="hljs-keyword">class</span> ExecutionProgress {
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> AsyncProgressWorker;
   <span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Signal</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        uv_async_send(that_-&gt;async);
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>You could do fancy generics with templates here.</p>

        </td>
        <td class="code highlight">
          <pre class="c">    void Send(const char* data, size_t size) const {
        that_-&gt;SendProgress_(data, size);
    }

   private:
    explicit ExecutionProgress(AsyncProgressWorker* that) : that_(that) {}
    NAN_DISALLOW_ASSIGN_COPY_MOVE(ExecutionProgress)
    AsyncProgressWorker* const that_;
  };

  virtual void Execute(const ExecutionProgress&amp; progress) = 0;
  virtual void HandleProgressCallback(const char *data, size_t size) = 0;

  virtual void Destroy() {
      uv_close(reinterpret_cast&lt;uv_handle_t*&gt;(async), AsyncClose_);
  }

 private:
  void Execute() /*final override*/ {
      ExecutionProgress progress(this);
      Execute(progress);
  }

  void SendProgress_(const char *data, size_t size) {
    char *new_data = new char[size];
    memcpy(new_data, data, size);

    uv_mutex_lock(&amp;async_lock);
    char *old_data = asyncdata_;
    asyncdata_ = new_data;
    asyncsize_ = size;
    uv_mutex_unlock(&amp;async_lock);

    delete[] old_data;
    uv_async_send(async);
  }

  inline static NAUV_WORK_CB(AsyncProgress_) {
    AsyncProgressWorker *worker =
            static_cast&lt;AsyncProgressWorker*&gt;(async-&gt;data);
    worker-&gt;WorkProgress();
  }

  inline static void AsyncClose_(uv_handle_t* handle) {
    AsyncProgressWorker *worker =
            static_cast&lt;AsyncProgressWorker*&gt;(handle-&gt;data);
    delete reinterpret_cast&lt;uv_async_t*&gt;(handle);
    delete worker;
  }

  uv_async_t *async;
  uv_mutex_t async_lock;
  char *asyncdata_;
  size_t asyncsize_;
};

inline void AsyncExecute (uv_work_t* req) {
  AsyncWorker *worker = static_cast&lt;AsyncWorker*&gt;(req-&gt;data);
  worker-&gt;Execute();
}

inline void AsyncExecuteComplete (uv_work_t* req) {
  AsyncWorker* worker = static_cast&lt;AsyncWorker*&gt;(req-&gt;data);
  worker-&gt;WorkComplete();
  worker-&gt;Destroy();
}

inline void AsyncQueueWorker (AsyncWorker* worker) {
  uv_queue_work(
      uv_default_loop()
    , &amp;worker-&gt;request
    , AsyncExecute
    , reinterpret_cast&lt;uv_after_work_cb&gt;(AsyncExecuteComplete)
  );
}

namespace imp {

inline
ExternalOneByteStringResource const*
GetExternalResource(v8::Local&lt;v8::String&gt; str) {
#if NODE_MODULE_VERSION &lt; ATOM_0_21_MODULE_VERSION
    return str-&gt;GetExternalAsciiStringResource();
#else
    return str-&gt;GetExternalOneByteStringResource();
#endif
}

inline
bool
IsExternal(v8::Local&lt;v8::String&gt; str) {
#if NODE_MODULE_VERSION &lt; ATOM_0_21_MODULE_VERSION
    return str-&gt;IsExternalAscii();
#else
    return str-&gt;IsExternalOneByte();
#endif
}

}  // end of namespace imp

enum Encoding {ASCII, UTF8, BASE64, UCS2, BINARY, HEX, BUFFER};

#if NODE_MODULE_VERSION &lt; NODE_0_10_MODULE_VERSION
# include "nan_string_bytes.h"  // NOLINT(build/include)
#endif

inline v8::Local&lt;v8::Value&gt; Encode(
    const void *buf, size_t len, enum Encoding encoding = BINARY) {
#if (NODE_MODULE_VERSION &gt;= ATOM_0_21_MODULE_VERSION)
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  node::encoding node_enc = static_cast&lt;node::encoding&gt;(encoding);

  if (encoding == UCS2) {
    return node::Encode(
        isolate
      , reinterpret_cast&lt;const uint16_t *&gt;(buf)
      , len / 2);
  } else {
    return node::Encode(
        isolate
      , reinterpret_cast&lt;const char *&gt;(buf)
      , len
      , node_enc);
  }
#elif (NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION)
  return node::Encode(
      v8::Isolate::GetCurrent()
    , buf, len
    , static_cast&lt;node::encoding&gt;(encoding));
#else
# if NODE_MODULE_VERSION &gt;= NODE_0_10_MODULE_VERSION
  return node::Encode(buf, len, static_cast&lt;node::encoding&gt;(encoding));
# else
  return imp::Encode(reinterpret_cast&lt;const char*&gt;(buf), len, encoding);
# endif
#endif
}

inline ssize_t DecodeBytes(
    v8::Local&lt;v8::Value&gt; val, enum Encoding encoding = BINARY) {
#if (NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION)
  return node::DecodeBytes(
      v8::Isolate::GetCurrent()
    , val
    , static_cast&lt;node::encoding&gt;(encoding));
#else
# if (NODE_MODULE_VERSION &lt; NODE_0_10_MODULE_VERSION)
  if (encoding == BUFFER) {
    return node::DecodeBytes(val, node::BINARY);
  }
# endif
  return node::DecodeBytes(val, static_cast&lt;node::encoding&gt;(encoding));
#endif
}

inline ssize_t DecodeWrite(
    char *buf
  , size_t len
  , v8::Local&lt;v8::Value&gt; val
  , enum Encoding encoding = BINARY) {
#if (NODE_MODULE_VERSION &gt; NODE_0_10_MODULE_VERSION)
  return node::DecodeWrite(
      v8::Isolate::GetCurrent()
    , buf
    , len
    , val
    , static_cast&lt;node::encoding&gt;(encoding));
#else
# if (NODE_MODULE_VERSION &lt; NODE_0_10_MODULE_VERSION)
  if (encoding == BUFFER) {
    return node::DecodeWrite(buf, len, val, node::BINARY);
  }
# endif
  return node::DecodeWrite(
      buf
    , len
    , val
    , static_cast&lt;node::encoding&gt;(encoding));
#endif
}

inline void SetPrototypeTemplate(
    v8::Local&lt;v8::FunctionTemplate&gt; templ
  , const char *name
  , v8::Local&lt;v8::Data&gt; value
) {
  SetTemplate(templ-&gt;PrototypeTemplate(), name, value);
}

inline void SetPrototypeTemplate(
    v8::Local&lt;v8::FunctionTemplate&gt; templ
  , v8::Local&lt;v8::String&gt; name
  , v8::Local&lt;v8::Data&gt; value
  , v8::PropertyAttribute attributes
) {
  SetTemplate(templ-&gt;PrototypeTemplate(), name, value, attributes);
}

inline void SetInstanceTemplate(
    v8::Local&lt;v8::FunctionTemplate&gt; templ
  , const char *name
  , v8::Local&lt;v8::Data&gt; value
) {
  SetTemplate(templ-&gt;InstanceTemplate(), name, value);
}

inline void SetInstanceTemplate(
    v8::Local&lt;v8::FunctionTemplate&gt; templ
  , v8::Local&lt;v8::String&gt; name
  , v8::Local&lt;v8::Data&gt; value
  , v8::PropertyAttribute attributes
) {
  SetTemplate(templ-&gt;InstanceTemplate(), name, value, attributes);
}

namespace imp {

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<p>Note(@agnat): Helper to distinguish different receiver types. The first
version deals with receivers derived from v8::Template. The second version
handles everything else. The final argument only serves as discriminator and
is unused.</p>

        </td>
        <td class="code highlight">
          <pre class="c"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span>
<span class="hljs-keyword">void</span>
<span class="hljs-title">SetMethodAux</span><span class="hljs-params">(T recv,
             v8::Local&lt;v8::String&gt; name,
             v8::Local&lt;v8::FunctionTemplate&gt; tpl,
             v8::Template *)</span> </span>{
  recv-&gt;Set(name, tpl);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span>
<span class="hljs-keyword">void</span>
<span class="hljs-title">SetMethodAux</span><span class="hljs-params">(T recv,
             v8::Local&lt;v8::String&gt; name,
             v8::Local&lt;v8::FunctionTemplate&gt; tpl,
             ...)</span> </span>{
  recv-&gt;Set(name, GetFunction(tpl).ToLocalChecked());
}

}  <span class="hljs-comment">// end of namespace imp</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> HandleType&gt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetMethod</span><span class="hljs-params">(
    HandleType&lt;T&gt; recv
  , <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name
  , FunctionCallback callback)</span> </span>{
  HandleScope scope;
  v8::Local&lt;v8::FunctionTemplate&gt; t = New&lt;v8::FunctionTemplate&gt;(callback);
  v8::Local&lt;v8::String&gt; fn_name = New(name).ToLocalChecked();
  t-&gt;SetClassName(fn_name);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<p>Note(@agnat): Pass an empty T* as discriminator. See note on
SetMethodAux(...) above</p>

        </td>
        <td class="code highlight">
          <pre class="c">  imp::SetMethodAux(recv, fn_name, t, <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(<span class="hljs-number">0</span>));
}

<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetPrototypeMethod</span><span class="hljs-params">(
    v8::Local&lt;v8::FunctionTemplate&gt; recv
  , <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name, FunctionCallback callback)</span> </span>{
  HandleScope scope;
  v8::Local&lt;v8::FunctionTemplate&gt; t = New&lt;v8::FunctionTemplate&gt;(
      callback
    , v8::Local&lt;v8::Value&gt;()
    , New&lt;v8::Signature&gt;(recv));
  v8::Local&lt;v8::String&gt; fn_name = New(name).ToLocalChecked();
  recv-&gt;PrototypeTemplate()-&gt;Set(fn_name, t);
  t-&gt;SetClassName(fn_name);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<p>=== Accessors and Such =======================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
inline void SetAccessor(
    v8::Local&lt;v8::ObjectTemplate&gt; tpl
  , v8::Local&lt;v8::String&gt; name
  , GetterCallback getter
  , SetterCallback setter = 0
  , v8::Local&lt;v8::Value&gt; data = v8::Local&lt;v8::Value&gt;()
  , v8::AccessControl settings = v8::DEFAULT
  , v8::PropertyAttribute attribute = v8::None
  , imp::Sig signature = imp::Sig()) {
  HandleScope scope;

  imp::NativeGetter getter_ =
      imp::GetterCallbackWrapper;
  imp::NativeSetter setter_ =
      setter ? imp::SetterCallbackWrapper : 0;

  v8::Local&lt;v8::ObjectTemplate&gt; otpl = New&lt;v8::ObjectTemplate&gt;();
  otpl-&gt;SetInternalFieldCount(imp::kAccessorFieldCount);
  v8::Local&lt;v8::Object&gt; obj = NewInstance(otpl).ToLocalChecked();

  obj-&gt;SetInternalField(
      imp::kGetterIndex
    , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(getter)));

  if (setter != 0) {
    obj-&gt;SetInternalField(
        imp::kSetterIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(setter)));
  }

  if (!data.IsEmpty()) {
    obj-&gt;SetInternalField(imp::kDataIndex, data);
  }

  tpl-&gt;SetAccessor(
      name
    , getter_
    , setter_
    , obj
    , settings
    , attribute
    , signature);
}

inline bool SetAccessor(
    v8::Local&lt;v8::Object&gt; obj
  , v8::Local&lt;v8::String&gt; name
  , GetterCallback getter
  , SetterCallback setter = 0
  , v8::Local&lt;v8::Value&gt; data = v8::Local&lt;v8::Value&gt;()
  , v8::AccessControl settings = v8::DEFAULT
  , v8::PropertyAttribute attribute = v8::None) {
  EscapableHandleScope scope;

  imp::NativeGetter getter_ =
      imp::GetterCallbackWrapper;
  imp::NativeSetter setter_ =
      setter ? imp::SetterCallbackWrapper : 0;

  v8::Local&lt;v8::ObjectTemplate&gt; otpl = New&lt;v8::ObjectTemplate&gt;();
  otpl-&gt;SetInternalFieldCount(imp::kAccessorFieldCount);
  v8::Local&lt;v8::Object&gt; dataobj = NewInstance(otpl).ToLocalChecked();

  dataobj-&gt;SetInternalField(
      imp::kGetterIndex
    , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(getter)));

  if (!data.IsEmpty()) {
    dataobj-&gt;SetInternalField(imp::kDataIndex, data);
  }

  if (setter) {
    dataobj-&gt;SetInternalField(
        imp::kSetterIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(setter)));
  }

#if (NODE_MODULE_VERSION &gt;= NODE_6_0_MODULE_VERSION)
  return obj-&gt;SetAccessor(
      GetCurrentContext()
    , name
    , getter_
    , setter_
    , dataobj
    , settings
    , attribute).FromMaybe(false);
#else
  return obj-&gt;SetAccessor(
      name
    , getter_
    , setter_
    , dataobj
    , settings
    , attribute);
#endif
}

inline void SetNamedPropertyHandler(
    v8::Local&lt;v8::ObjectTemplate&gt; tpl
  , PropertyGetterCallback getter
  , PropertySetterCallback setter = 0
  , PropertyQueryCallback query = 0
  , PropertyDeleterCallback deleter = 0
  , PropertyEnumeratorCallback enumerator = 0
  , v8::Local&lt;v8::Value&gt; data = v8::Local&lt;v8::Value&gt;()) {
  HandleScope scope;

  imp::NativePropertyGetter getter_ =
      imp::PropertyGetterCallbackWrapper;
  imp::NativePropertySetter setter_ =
      setter ? imp::PropertySetterCallbackWrapper : 0;
  imp::NativePropertyQuery query_ =
      query ? imp::PropertyQueryCallbackWrapper : 0;
  imp::NativePropertyDeleter *deleter_ =
      deleter ? imp::PropertyDeleterCallbackWrapper : 0;
  imp::NativePropertyEnumerator enumerator_ =
      enumerator ? imp::PropertyEnumeratorCallbackWrapper : 0;

  v8::Local&lt;v8::ObjectTemplate&gt; otpl = New&lt;v8::ObjectTemplate&gt;();
  otpl-&gt;SetInternalFieldCount(imp::kPropertyFieldCount);
  v8::Local&lt;v8::Object&gt; obj = NewInstance(otpl).ToLocalChecked();
  obj-&gt;SetInternalField(
      imp::kPropertyGetterIndex
    , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(getter)));

  if (setter) {
    obj-&gt;SetInternalField(
        imp::kPropertySetterIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(setter)));
  }

  if (query) {
    obj-&gt;SetInternalField(
        imp::kPropertyQueryIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(query)));
  }

  if (deleter) {
    obj-&gt;SetInternalField(
        imp::kPropertyDeleterIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(deleter)));
  }

  if (enumerator) {
    obj-&gt;SetInternalField(
        imp::kPropertyEnumeratorIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(enumerator)));
  }

  if (!data.IsEmpty()) {
    obj-&gt;SetInternalField(imp::kDataIndex, data);
  }

#if NODE_MODULE_VERSION &gt; NODE_0_12_MODULE_VERSION
  tpl-&gt;SetHandler(v8::NamedPropertyHandlerConfiguration(
      getter_, setter_, query_, deleter_, enumerator_, obj));
#else
  tpl-&gt;SetNamedPropertyHandler(
      getter_
    , setter_
    , query_
    , deleter_
    , enumerator_
    , obj);
#endif
}

inline void SetIndexedPropertyHandler(
    v8::Local&lt;v8::ObjectTemplate&gt; tpl
  , IndexGetterCallback getter
  , IndexSetterCallback setter = 0
  , IndexQueryCallback query = 0
  , IndexDeleterCallback deleter = 0
  , IndexEnumeratorCallback enumerator = 0
  , v8::Local&lt;v8::Value&gt; data = v8::Local&lt;v8::Value&gt;()) {
  HandleScope scope;

  imp::NativeIndexGetter getter_ =
      imp::IndexGetterCallbackWrapper;
  imp::NativeIndexSetter setter_ =
      setter ? imp::IndexSetterCallbackWrapper : 0;
  imp::NativeIndexQuery query_ =
      query ? imp::IndexQueryCallbackWrapper : 0;
  imp::NativeIndexDeleter deleter_ =
      deleter ? imp::IndexDeleterCallbackWrapper : 0;
  imp::NativeIndexEnumerator enumerator_ =
      enumerator ? imp::IndexEnumeratorCallbackWrapper : 0;

  v8::Local&lt;v8::ObjectTemplate&gt; otpl = New&lt;v8::ObjectTemplate&gt;();
  otpl-&gt;SetInternalFieldCount(imp::kIndexPropertyFieldCount);
  v8::Local&lt;v8::Object&gt; obj = NewInstance(otpl).ToLocalChecked();
  obj-&gt;SetInternalField(
      imp::kIndexPropertyGetterIndex
    , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(getter)));

  if (setter) {
    obj-&gt;SetInternalField(
        imp::kIndexPropertySetterIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(setter)));
  }

  if (query) {
    obj-&gt;SetInternalField(
        imp::kIndexPropertyQueryIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(query)));
  }

  if (deleter) {
    obj-&gt;SetInternalField(
        imp::kIndexPropertyDeleterIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(deleter)));
  }

  if (enumerator) {
    obj-&gt;SetInternalField(
        imp::kIndexPropertyEnumeratorIndex
      , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(enumerator)));
  }

  if (!data.IsEmpty()) {
    obj-&gt;SetInternalField(imp::kDataIndex, data);
  }

#if NODE_MODULE_VERSION &gt; NODE_0_12_MODULE_VERSION
  tpl-&gt;SetHandler(v8::IndexedPropertyHandlerConfiguration(
      getter_, setter_, query_, deleter_, enumerator_, obj));
#else
  tpl-&gt;SetIndexedPropertyHandler(
      getter_
    , setter_
    , query_
    , deleter_
    , enumerator_
    , obj);
#endif
}

inline void SetCallHandler(
    v8::Local&lt;v8::FunctionTemplate&gt; tpl
  , FunctionCallback callback
  , v8::Local&lt;v8::Value&gt; data = v8::Local&lt;v8::Value&gt;()) {
  HandleScope scope;

  v8::Local&lt;v8::ObjectTemplate&gt; otpl = New&lt;v8::ObjectTemplate&gt;();
  otpl-&gt;SetInternalFieldCount(imp::kFunctionFieldCount);
  v8::Local&lt;v8::Object&gt; obj = NewInstance(otpl).ToLocalChecked();

  obj-&gt;SetInternalField(
      imp::kFunctionIndex
    , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(callback)));

  if (!data.IsEmpty()) {
    obj-&gt;SetInternalField(imp::kDataIndex, data);
  }

  tpl-&gt;SetCallHandler(imp::FunctionCallbackWrapper, obj);
}


inline void SetCallAsFunctionHandler(
    v8::Local&lt;v8::ObjectTemplate&gt; tpl,
    FunctionCallback callback,
    v8::Local&lt;v8::Value&gt; data = v8::Local&lt;v8::Value&gt;()) {
  HandleScope scope;

  v8::Local&lt;v8::ObjectTemplate&gt; otpl = New&lt;v8::ObjectTemplate&gt;();
  otpl-&gt;SetInternalFieldCount(imp::kFunctionFieldCount);
  v8::Local&lt;v8::Object&gt; obj = NewInstance(otpl).ToLocalChecked();

  obj-&gt;SetInternalField(
      imp::kFunctionIndex
    , New&lt;v8::External&gt;(reinterpret_cast&lt;void *&gt;(callback)));

  if (!data.IsEmpty()) {
    obj-&gt;SetInternalField(imp::kDataIndex, data);
  }

  tpl-&gt;SetCallAsFunctionHandler(imp::FunctionCallbackWrapper, obj);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<p>=== Weak Persistent Handling =================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nan_weak.h"</span>  <span class="hljs-comment">// NOLINT(build/include)</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<p>=== ObjectWrap ===============================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nan_object_wrap.h"</span>  <span class="hljs-comment">// NOLINT(build/include)</span></span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<p>=== Export ==================================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-function"><span class="hljs-keyword">inline</span>
<span class="hljs-keyword">void</span>
<span class="hljs-title">Export</span><span class="hljs-params">(ADDON_REGISTER_FUNCTION_ARGS_TYPE target, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name,
    FunctionCallback f)</span> </span>{
  Set(target, New&lt;v8::String&gt;(name).ToLocalChecked(),
      GetFunction(New&lt;v8::FunctionTemplate&gt;(f)).ToLocalChecked());
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<p>=== Tap Reverse Binding =====================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
struct Tap {
  explicit Tap(v8::Local&lt;v8::Value&gt; t) : t_() {
    t_.Reset(To&lt;v8::Object&gt;(t).ToLocalChecked());
  }

  ~Tap() { t_.Reset(); }  // not sure if neccessary

  inline void plan(int i) {
    v8::Local&lt;v8::Value&gt; arg = New(i);
    MakeCallback(New(t_), "plan", 1, &amp;arg);
  }

  inline void ok(bool isOk, const char *msg = NULL) {
    v8::Local&lt;v8::Value&gt; args[2];
    args[0] = New(isOk);
    if (msg) args[1] = New(msg).ToLocalChecked();
    MakeCallback(New(t_), "ok", msg ? 2 : 1, args);
  }

  inline void pass(const char * msg = NULL) {
    v8::Local&lt;v8::Value&gt; hmsg;
    if (msg) hmsg = New(msg).ToLocalChecked();
    MakeCallback(New(t_), "pass", msg ? 1 : 0, &amp;hmsg);
  }

 private:
  Persistent&lt;v8::Object&gt; t_;
};

#define NAN_STRINGIZE2(x) #x
#define NAN_STRINGIZE(x) NAN_STRINGIZE2(x)
#define NAN_TEST_EXPRESSION(expression) \
  ( expression ), __FILE__ ":" NAN_STRINGIZE(__LINE__) ": " #expression

#define NAN_EXPORT(target, function) Export(target, #function, function)

#undef TYPE_CHECK

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<p>=== Generic Maybefication ===================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-keyword">namespace</span> imp {

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> Maybefier;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> Maybefier&lt;v8::Local&lt;T&gt; &gt; {
  <span class="hljs-keyword">static</span> MaybeLocal&lt;T&gt; convert(v8::Local&lt;T&gt; v) {
    <span class="hljs-keyword">return</span> MaybeLocal&lt;T&gt;(v);
  }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> Maybefier&lt;MaybeLocal&lt;T&gt; &gt; {
  <span class="hljs-keyword">static</span> MaybeLocal&lt;T&gt; convert(MaybeLocal&lt;T&gt; v) {
    <span class="hljs-keyword">return</span> v;
  }
};

}  <span class="hljs-comment">// end of namespace imp</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> MaybeMaybe&gt;
MaybeLocal&lt;T&gt;
MakeMaybe(MaybeMaybe&lt;T&gt; v) {
  <span class="hljs-keyword">return</span> imp::Maybefier&lt;MaybeMaybe&lt;T&gt; &gt;::convert(v);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<p>=== TypedArrayContents =======================================================</p>

        </td>
        <td class="code highlight">
          <pre class="c">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"nan_typedarray_contents.h"</span>  <span class="hljs-comment">// NOLINT(build/include)</span></span>

}  <span class="hljs-comment">// end of namespace Nan</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// NAN_H_</span></span>

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
