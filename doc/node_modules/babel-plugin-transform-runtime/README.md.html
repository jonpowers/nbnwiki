<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/babel-plugin-transform-runtime/README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#babel-plugin-transform-runtime">babel-plugin-transform-runtime</a>
      </div>

      <div class="heading h2">
        <a href="#why">Why?</a>
      </div>

      <div class="heading h2">
        <a href="#installation">Installation</a>
      </div>

      <div class="heading h2">
        <a href="#usage">Usage</a>
      </div>

      <div class="heading h3">
        <a href="#via.babelrc-recommended">Via .babelrc (Recommended)</a>
      </div>

      <div class="heading h3">
        <a href="#via-cli">Via CLI</a>
      </div>

      <div class="heading h3">
        <a href="#via-node-api">Via Node API</a>
      </div>

      <div class="heading h2">
        <a href="#technical-details">Technical details</a>
      </div>

      <div class="heading h3">
        <a href="#regenerator-aliasing">Regenerator aliasing</a>
      </div>

      <div class="heading h3">
        <a href="#core-js-aliasing">core-js aliasing</a>
      </div>

      <div class="heading h3">
        <a href="#helper-aliasing">Helper aliasing</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><div class="pilwrap" id="babel-plugin-transform-runtime">
  <h1>
    <a href="#babel-plugin-transform-runtime" name="babel-plugin-transform-runtime" class="pilcrow"></a>
babel-plugin-transform-runtime
  </h1>
</div>
<blockquote>
<p>Externalise references to helpers and builtins, automatically polyfilling your code without polluting globals. (This plugin is recommended in a library/tool)</p>
</blockquote>
<p>NOTE: Instance methods such as <code>&quot;foobar&quot;.includes(&quot;foo&quot;)</code> will not work since that would require modification of existing builtins (Use <a href="http://babeljs.io/docs/usage/polyfill"><code>babel-polyfill</code></a> for that).</p>
<div class="pilwrap" id="why">
  <h2>
    <a href="#why" name="why" class="pilcrow"></a>
Why?
  </h2>
</div>
<p>Babel uses very small helpers for common functions such as <code>_extend</code>. By default this will be added to every file that requires it. This duplication is sometimes unnecessary, especially when your application is spread out over multiple files.</p>
<p>This is where the <code>transform-runtime</code> plugin comes in: all of the helpers will reference the module <code>babel-runtime</code> to avoid duplication across your compiled output. The runtime will be compiled into your build.</p>
<p>Another purpose of this transformer is to create a sandboxed environment for your code. If you use <a href="http://babeljs.io/docs/usage/polyfill/">babel-polyfill</a> and the built-ins it provides such as <code>Promise</code>, <code>Set</code> and <code>Map</code>, those will pollute the global scope. While this might be ok for an app or a command line tool, it becomes a problem if your code is a library which you intend to publish for others to use or if you can't exactly control the environment in which your code will run.</p>
<p>The transformer will alias these built-ins to <code>core-js</code> so you can use them seamlessly without having to require the polyfill.</p>
<p>See the <a href="#technical-details.html">technical details</a> section for more information on how this works and the types of transformations that occur.</p>
<div class="pilwrap" id="installation">
  <h2>
    <a href="#installation" name="installation" class="pilcrow"></a>
Installation
  </h2>
</div>
<p><strong>NOTE - Production vs. development dependencies</strong></p>
<p>In most cases, you should install <code>babel-plugin-transform-runtime</code> as a development dependency (with <code>--save-dev</code>).</p>
<pre><code class="sh">npm install --save-dev babel-plugin-transform-runtime
</code></pre>
<p>and <code>babel-runtime</code> as a production dependency (with <code>--save</code>).</p>
<pre><code class="sh">npm install --save babel-runtime
</code></pre>
<p>The transformation plugin is typically used only in development, but the runtime itself will be depended on by your deployed/published code. See the examples below for more details.</p>
<div class="pilwrap" id="usage">
  <h2>
    <a href="#usage" name="usage" class="pilcrow"></a>
Usage
  </h2>
</div>
<div class="pilwrap" id="via.babelrc-recommended">
  <h3>
    <a href="#via.babelrc-recommended" name="via.babelrc-recommended" class="pilcrow"></a>
Via <code>.babelrc</code> (Recommended)
  </h3>
</div>
<p>Add the following line to your <code>.babelrc</code> file:</p>
<pre><code class="js"><span class="hljs-comment">// without options</span>
{
  <span class="hljs-string">"plugins"</span>: [<span class="hljs-string">"transform-runtime"</span>]
}

<span class="hljs-comment">// with options</span>
{
  <span class="hljs-string">"plugins"</span>: [
    [<span class="hljs-string">"transform-runtime"</span>, {
      <span class="hljs-string">"helpers"</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// defaults to true</span>
      <span class="hljs-string">"polyfill"</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// defaults to true</span>
      <span class="hljs-string">"regenerator"</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// defaults to true</span>
      <span class="hljs-string">"moduleName"</span>: <span class="hljs-string">"babel-runtime"</span> <span class="hljs-comment">// defaults to "babel-runtime"</span>
    }]
  ]
}
</code></pre>
<div class="pilwrap" id="via-cli">
  <h3>
    <a href="#via-cli" name="via-cli" class="pilcrow"></a>
Via CLI
  </h3>
</div>
<pre><code class="sh">babel --plugins transform-runtime script.js
</code></pre>
<div class="pilwrap" id="via-node-api">
  <h3>
    <a href="#via-node-api" name="via-node-api" class="pilcrow"></a>
Via Node API
  </h3>
</div>
<pre><code class="javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">"babel-core"</span>).transform(<span class="hljs-string">"code"</span>, {
  <span class="hljs-attr">plugins</span>: [<span class="hljs-string">"transform-runtime"</span>]
});
</code></pre>
<div class="pilwrap" id="technical-details">
  <h2>
    <a href="#technical-details" name="technical-details" class="pilcrow"></a>
Technical details
  </h2>
</div>
<p>The <code>runtime</code> transformer plugin does three things:</p>
<ul>
<li>Automatically requires <code>babel-runtime/regenerator</code> when you use generators/async functions.</li>
<li>Automatically requires <code>babel-runtime/core-js</code> and maps ES6 static methods and built-ins.</li>
<li>Removes the inline babel helpers and uses the module <code>babel-runtime/helpers</code> instead.</li>
</ul>
<p>What does this actually mean though? Basically, you can use built-ins such as <code>Promise</code>, <code>Set</code>, <code>Symbol</code> etc as well use all the Babel features that require a polyfill seamlessly, without global pollution, making it extremely suitable for libraries.</p>
<p>Make sure you include <code>babel-runtime</code> as a dependency.</p>
<div class="pilwrap" id="regenerator-aliasing">
  <h3>
    <a href="#regenerator-aliasing" name="regenerator-aliasing" class="pilcrow"></a>
Regenerator aliasing
  </h3>
</div>
<p>Whenever you use a generator function or async function:</p>
<pre><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{

}
</code></pre>
<p>the following is generated:</p>
<pre><code class="javascript"><span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">var</span> _marked = [foo].map(regeneratorRuntime.mark);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> regeneratorRuntime.wrap(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo$</span>(<span class="hljs-params">_context</span>) </span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) <span class="hljs-keyword">switch</span> (_context.prev = _context.next) {
      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">"end"</span>:
        <span class="hljs-keyword">return</span> _context.stop();
    }
  }, _marked[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>);
}
</code></pre>
<p>This isn't ideal as then you have to include the regenerator runtime which
pollutes the global scope.</p>
<p>Instead what the <code>runtime</code> transformer does it compile that to:</p>
<pre><code class="javascript"><span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">var</span> _regenerator = <span class="hljs-built_in">require</span>(<span class="hljs-string">"babel-runtime/regenerator"</span>);

<span class="hljs-keyword">var</span> _regenerator2 = _interopRequireDefault(_regenerator);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_interopRequireDefault</span>(<span class="hljs-params">obj</span>) </span>{ <span class="hljs-keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : { <span class="hljs-attr">default</span>: obj }; }

<span class="hljs-keyword">var</span> _marked = [foo].map(_regenerator2.default.mark);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> regeneratorRuntime.wrap(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo$</span>(<span class="hljs-params">_context</span>) </span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) <span class="hljs-keyword">switch</span> (_context.prev = _context.next) {
      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">"end"</span>:
        <span class="hljs-keyword">return</span> _context.stop();
    }
  }, _marked[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>);
}
</code></pre>
<p>This means that you can use the regenerator runtime without polluting your current environment.</p>
<div class="pilwrap" id="core-js-aliasing">
  <h3>
    <a href="#core-js-aliasing" name="core-js-aliasing" class="pilcrow"></a>
<code>core-js</code> aliasing
  </h3>
</div>
<p>Sometimes you may want to use new built-ins such as <code>Map</code>, <code>Set</code>, <code>Promise</code> etc. Your only way
to use these is usually to include a globally polluting polyfill.</p>
<p>What the <code>runtime</code> transformer does is transform the following:</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> sym = <span class="hljs-built_in">Symbol</span>();

<span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>;

<span class="hljs-built_in">console</span>.log(arr[<span class="hljs-built_in">Symbol</span>.iterator]());
</code></pre>
<p>into the following:</p>
<pre><code class="javascript"><span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">var</span> _getIterator2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">"babel-runtime/core-js/get-iterator"</span>);

<span class="hljs-keyword">var</span> _getIterator3 = _interopRequireDefault(_getIterator2);

<span class="hljs-keyword">var</span> _promise = <span class="hljs-built_in">require</span>(<span class="hljs-string">"babel-runtime/core-js/promise"</span>);

<span class="hljs-keyword">var</span> _promise2 = _interopRequireDefault(_promise);

<span class="hljs-keyword">var</span> _symbol = <span class="hljs-built_in">require</span>(<span class="hljs-string">"babel-runtime/core-js/symbol"</span>);

<span class="hljs-keyword">var</span> _symbol2 = _interopRequireDefault(_symbol);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_interopRequireDefault</span>(<span class="hljs-params">obj</span>) </span>{ <span class="hljs-keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : { <span class="hljs-attr">default</span>: obj }; }

<span class="hljs-keyword">var</span> sym = (<span class="hljs-number">0</span>, _symbol2.default)();

<span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> _promise2.default();

<span class="hljs-built_in">console</span>.log((<span class="hljs-number">0</span>, _getIterator3.default)(arr));
</code></pre>
<p>This means is that you can seamlessly use these native built-ins and static methods
without worrying about where they come from.</p>
<p><strong>NOTE:</strong> Instance methods such as <code>&quot;foobar&quot;.includes(&quot;foo&quot;)</code> will <strong>not</strong> work.</p>
<div class="pilwrap" id="helper-aliasing">
  <h3>
    <a href="#helper-aliasing" name="helper-aliasing" class="pilcrow"></a>
Helper aliasing
  </h3>
</div>
<p>Usually babel will place helpers at the top of your file to do common tasks to avoid
duplicating the code around in the current file. Sometimes these helpers can get a
little bulky and add unnecessary duplication across files. The <code>runtime</code>
transformer replaces all the helper calls to a module.</p>
<p>That means that the following code:</p>
<pre><code class="javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
}
</code></pre>
<p>usually turns into:</p>
<pre><code class="javascript"><span class="hljs-meta">"use strict"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_classCallCheck</span>(<span class="hljs-params">instance, Constructor</span>) </span>{ <span class="hljs-keyword">if</span> (!(instance <span class="hljs-keyword">instanceof</span> Constructor)) { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Cannot call a class as a function"</span>); } }

<span class="hljs-keyword">var</span> Person = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>{
  _classCallCheck(<span class="hljs-keyword">this</span>, Person);
};
</code></pre>
<p>the <code>runtime</code> transformer however turns this into:</p>
<pre><code class="javascript"><span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">var</span> _classCallCheck2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">"babel-runtime/helpers/classCallCheck"</span>);

<span class="hljs-keyword">var</span> _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_interopRequireDefault</span>(<span class="hljs-params">obj</span>) </span>{ <span class="hljs-keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : { <span class="hljs-attr">default</span>: obj }; }

<span class="hljs-keyword">var</span> Person = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>{
  (<span class="hljs-number">0</span>, _classCallCheck3.default)(<span class="hljs-keyword">this</span>, Person);
};
</code></pre>
</div>
  </div>
</body>
</html>
