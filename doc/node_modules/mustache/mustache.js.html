<!DOCTYPE html>
<html>
<head>
  <title>mustache.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/mustache/mustache.js";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>mustache.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>
<div class="dox">
<div class="summary">
<p>!
mustache.js - Logic-less {{mustache}} templates with JavaScript
http://github.com/janl/mustache.js</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-comment">/*global define: false Mustache: true*/</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineMustache</span> (<span class="hljs-params">global, factory</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exports === <span class="hljs-string">'object'</span> &amp;&amp; exports &amp;&amp; <span class="hljs-keyword">typeof</span> exports.nodeName !== <span class="hljs-string">'string'</span>) {
    factory(exports); <span class="hljs-comment">// CommonJS</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">'function'</span> &amp;&amp; define.amd) {
    define([<span class="hljs-string">'exports'</span>], factory); <span class="hljs-comment">// AMD</span>
  } <span class="hljs-keyword">else</span> {
    global.Mustache = {};
    factory(global.Mustache); <span class="hljs-comment">// script, wsh, asp</span>
  }
}(<span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mustacheFactory</span> (<span class="hljs-params">mustache</span>) </span>{

  <span class="hljs-keyword">var</span> objectToString = <span class="hljs-built_in">Object</span>.prototype.toString;
  <span class="hljs-keyword">var</span> isArray = <span class="hljs-built_in">Array</span>.isArray || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArrayPolyfill</span> (<span class="hljs-params">object</span>) </span>{
    <span class="hljs-keyword">return</span> objectToString.call(object) === <span class="hljs-string">'[object Array]'</span>;
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFunction</span> (<span class="hljs-params">object</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> object === <span class="hljs-string">'function'</span>;
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<div class="dox">
<div class="summary">
<p>More correct typeof string handling array
which normally returns typeof 'object'</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">typeStr</span> (<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">return</span> isArray(obj) ? <span class="hljs-string">'array'</span> : <span class="hljs-keyword">typeof</span> obj;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">escapeRegExp</span> (<span class="hljs-params">string</span>) </span>{
    <span class="hljs-keyword">return</span> string.replace(<span class="hljs-regexp">/[\-\[\]{}()*+?.,\\\^$|#\s]/g</span>, <span class="hljs-string">'\\$&amp;'</span>);
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<div class="dox">
<div class="summary">
<p>Null safe way of checking whether or not an object,
including its prototype, has a given property</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasProperty</span> (<span class="hljs-params">obj, propName</span>) </span>{
    <span class="hljs-keyword">return</span> obj != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'object'</span> &amp;&amp; (propName <span class="hljs-keyword">in</span> obj);
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
See https://github.com/janl/mustache.js/issues/189</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> regExpTest = <span class="hljs-built_in">RegExp</span>.prototype.test;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testRegExp</span> (<span class="hljs-params">re, string</span>) </span>{
    <span class="hljs-keyword">return</span> regExpTest.call(re, string);
  }

  <span class="hljs-keyword">var</span> nonSpaceRe = <span class="hljs-regexp">/\S/</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isWhitespace</span> (<span class="hljs-params">string</span>) </span>{
    <span class="hljs-keyword">return</span> !testRegExp(nonSpaceRe, string);
  }

  <span class="hljs-keyword">var</span> entityMap = {
    <span class="hljs-string">'&amp;'</span>: <span class="hljs-string">'&amp;amp;'</span>,
    <span class="hljs-string">'&lt;'</span>: <span class="hljs-string">'&amp;lt;'</span>,
    <span class="hljs-string">'&gt;'</span>: <span class="hljs-string">'&amp;gt;'</span>,
    <span class="hljs-string">'"'</span>: <span class="hljs-string">'&amp;quot;'</span>,
    <span class="hljs-string">"'"</span>: <span class="hljs-string">'&amp;#39;'</span>,
    <span class="hljs-string">'/'</span>: <span class="hljs-string">'&amp;#x2F;'</span>,
    <span class="hljs-string">'`'</span>: <span class="hljs-string">'&amp;#x60;'</span>,
    <span class="hljs-string">'='</span>: <span class="hljs-string">'&amp;#x3D;'</span>
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">escapeHtml</span> (<span class="hljs-params">string</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(string).replace(<span class="hljs-regexp">/[&amp;&lt;&gt;"'`=\/]/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromEntityMap</span> (<span class="hljs-params">s</span>) </span>{
      <span class="hljs-keyword">return</span> entityMap[s];
    });
  }

  <span class="hljs-keyword">var</span> whiteRe = <span class="hljs-regexp">/\s*/</span>;
  <span class="hljs-keyword">var</span> spaceRe = <span class="hljs-regexp">/\s+/</span>;
  <span class="hljs-keyword">var</span> equalsRe = <span class="hljs-regexp">/\s*=/</span>;
  <span class="hljs-keyword">var</span> curlyRe = <span class="hljs-regexp">/\s*\}/</span>;
  <span class="hljs-keyword">var</span> tagRe = <span class="hljs-regexp">/#|\^|\/|&gt;|\{|&amp;|=|!/</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<div class="dox">
<div class="summary">
<p>Breaks up the given <code>template</code> string into a tree of tokens. If the <code>tags</code>
argument is given here it must be an array with two string values: the
opening and closing tags used in the template (e.g. [ &quot;&lt;%&quot;, &quot;%&gt;&quot; ]). Of
course, the default is to use mustaches (i.e. mustache.tags).</p>
</div>
<div class="body">
<p>A token is an array with at least 4 elements. The first element is the
mustache symbol that was used inside the tag, e.g. &quot;#&quot; or &quot;&amp;&quot;. If the tag
did not contain a symbol (i.e. {{myValue}}) this element is &quot;name&quot;. For
all text that appears outside a symbol this element is &quot;text&quot;.</p>
<p>The second element of a token is its &quot;value&quot;. For mustache tags this is
whatever else was inside the tag besides the opening symbol. For text tokens
this is the text itself.</p>
<p>The third and fourth elements of the token are the start and end indices,
respectively, of the token in the original template.</p>
<p>Tokens that are the root node of a subtree contain two more elements: 1) an
array of tokens in the subtree and 2) the index in the original template at
which the closing tag for that section begins.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseTemplate</span> (<span class="hljs-params">template, tags</span>) </span>{
    <span class="hljs-keyword">if</span> (!template)
      <span class="hljs-keyword">return</span> [];

    <span class="hljs-keyword">var</span> sections = [];     <span class="hljs-comment">// Stack to hold section tokens</span>
    <span class="hljs-keyword">var</span> tokens = [];       <span class="hljs-comment">// Buffer to hold the tokens</span>
    <span class="hljs-keyword">var</span> spaces = [];       <span class="hljs-comment">// Indices of whitespace tokens on the current line</span>
    <span class="hljs-keyword">var</span> hasTag = <span class="hljs-literal">false</span>;    <span class="hljs-comment">// Is there a {{tag}} on the current line?</span>
    <span class="hljs-keyword">var</span> nonSpace = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// Is there a non-space char on the current line?</span>

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Strips all whitespace tokens array for the current line
if there was a {{#tag}} on it and otherwise only space.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stripSpace</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (hasTag &amp;&amp; !nonSpace) {
        <span class="hljs-keyword">while</span> (spaces.length)
          <span class="hljs-keyword">delete</span> tokens[spaces.pop()];
      } <span class="hljs-keyword">else</span> {
        spaces = [];
      }

      hasTag = <span class="hljs-literal">false</span>;
      nonSpace = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> openingTagRe, closingTagRe, closingCurlyRe;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compileTags</span> (<span class="hljs-params">tagsToCompile</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> tagsToCompile === <span class="hljs-string">'string'</span>)
        tagsToCompile = tagsToCompile.split(spaceRe, <span class="hljs-number">2</span>);

      <span class="hljs-keyword">if</span> (!isArray(tagsToCompile) || tagsToCompile.length !== <span class="hljs-number">2</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Invalid tags: '</span> + tagsToCompile);

      openingTagRe = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(escapeRegExp(tagsToCompile[<span class="hljs-number">0</span>]) + <span class="hljs-string">'\\s*'</span>);
      closingTagRe = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'\\s*'</span> + escapeRegExp(tagsToCompile[<span class="hljs-number">1</span>]));
      closingCurlyRe = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'\\s*'</span> + escapeRegExp(<span class="hljs-string">'}'</span> + tagsToCompile[<span class="hljs-number">1</span>]));
    }

    compileTags(tags || mustache.tags);

    <span class="hljs-keyword">var</span> scanner = <span class="hljs-keyword">new</span> Scanner(template);

    <span class="hljs-keyword">var</span> start, type, value, chr, token, openSection;
    <span class="hljs-keyword">while</span> (!scanner.eos()) {
      start = scanner.pos;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>Match any text between tags.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      value = scanner.scanUntil(openingTagRe);

      <span class="hljs-keyword">if</span> (value) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, valueLength = value.length; i &lt; valueLength; ++i) {
          chr = value.charAt(i);

          <span class="hljs-keyword">if</span> (isWhitespace(chr)) {
            spaces.push(tokens.length);
          } <span class="hljs-keyword">else</span> {
            nonSpace = <span class="hljs-literal">true</span>;
          }

          tokens.push([ <span class="hljs-string">'text'</span>, chr, start, start + <span class="hljs-number">1</span> ]);
          start += <span class="hljs-number">1</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>Check for whitespace on the current line.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (chr === <span class="hljs-string">'\n'</span>)
            stripSpace();
        }
      }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>Match the opening tag.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (!scanner.scan(openingTagRe))
        <span class="hljs-keyword">break</span>;

      hasTag = <span class="hljs-literal">true</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>Get the tag type.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      type = scanner.scan(tagRe) || <span class="hljs-string">'name'</span>;
      scanner.scan(whiteRe);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>Get the tag value.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'='</span>) {
        value = scanner.scanUntil(equalsRe);
        scanner.scan(equalsRe);
        scanner.scanUntil(closingTagRe);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'{'</span>) {
        value = scanner.scanUntil(closingCurlyRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(closingTagRe);
        type = <span class="hljs-string">'&amp;'</span>;
      } <span class="hljs-keyword">else</span> {
        value = scanner.scanUntil(closingTagRe);
      }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>Match the closing tag.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (!scanner.scan(closingTagRe))
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unclosed tag at '</span> + scanner.pos);

      token = [ type, value, start, scanner.pos ];
      tokens.push(token);

      <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'#'</span> || type === <span class="hljs-string">'^'</span>) {
        sections.push(token);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'/'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>Check section nesting.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        openSection = sections.pop();

        <span class="hljs-keyword">if</span> (!openSection)
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unopened section "'</span> + value + <span class="hljs-string">'" at '</span> + start);

        <span class="hljs-keyword">if</span> (openSection[<span class="hljs-number">1</span>] !== value)
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unclosed section "'</span> + openSection[<span class="hljs-number">1</span>] + <span class="hljs-string">'" at '</span> + start);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'name'</span> || type === <span class="hljs-string">'{'</span> || type === <span class="hljs-string">'&amp;'</span>) {
        nonSpace = <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'='</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>Set the tags for the next time around.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        compileTags(value);
      }
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>Make sure there are no open sections when we're done.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    openSection = sections.pop();

    <span class="hljs-keyword">if</span> (openSection)
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unclosed section "'</span> + openSection[<span class="hljs-number">1</span>] + <span class="hljs-string">'" at '</span> + scanner.pos);

    <span class="hljs-keyword">return</span> nestTokens(squashTokens(tokens));
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<div class="dox">
<div class="summary">
<p>Combines the values of consecutive text tokens in the given <code>tokens</code> array
to a single token.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">squashTokens</span> (<span class="hljs-params">tokens</span>) </span>{
    <span class="hljs-keyword">var</span> squashedTokens = [];

    <span class="hljs-keyword">var</span> token, lastToken;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, numTokens = tokens.length; i &lt; numTokens; ++i) {
      token = tokens[i];

      <span class="hljs-keyword">if</span> (token) {
        <span class="hljs-keyword">if</span> (token[<span class="hljs-number">0</span>] === <span class="hljs-string">'text'</span> &amp;&amp; lastToken &amp;&amp; lastToken[<span class="hljs-number">0</span>] === <span class="hljs-string">'text'</span>) {
          lastToken[<span class="hljs-number">1</span>] += token[<span class="hljs-number">1</span>];
          lastToken[<span class="hljs-number">3</span>] = token[<span class="hljs-number">3</span>];
        } <span class="hljs-keyword">else</span> {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
    }

    <span class="hljs-keyword">return</span> squashedTokens;
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<div class="dox">
<div class="summary">
<p>Forms the given array of <code>tokens</code> into a nested tree structure where
tokens that represent a section have two additional items: 1) an array of
all tokens that appear in that section and 2) the index in the original
template that represents the end of that section.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nestTokens</span> (<span class="hljs-params">tokens</span>) </span>{
    <span class="hljs-keyword">var</span> nestedTokens = [];
    <span class="hljs-keyword">var</span> collector = nestedTokens;
    <span class="hljs-keyword">var</span> sections = [];

    <span class="hljs-keyword">var</span> token, section;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, numTokens = tokens.length; i &lt; numTokens; ++i) {
      token = tokens[i];

      <span class="hljs-keyword">switch</span> (token[<span class="hljs-number">0</span>]) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'#'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'^'</span>:
          collector.push(token);
          sections.push(token);
          collector = token[<span class="hljs-number">4</span>] = [];
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:
          section = sections.pop();
          section[<span class="hljs-number">5</span>] = token[<span class="hljs-number">2</span>];
          collector = sections.length &gt; <span class="hljs-number">0</span> ? sections[sections.length - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>] : nestedTokens;
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
          collector.push(token);
      }
    }

    <span class="hljs-keyword">return</span> nestedTokens;
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<div class="dox">
<div class="summary">
<p>A simple string scanner that is used by the template parser to find
tokens in template strings.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Scanner</span> (<span class="hljs-params">string</span>) </span>{
    <span class="hljs-keyword">this</span>.string = string;
    <span class="hljs-keyword">this</span>.tail = string;
    <span class="hljs-keyword">this</span>.pos = <span class="hljs-number">0</span>;
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns <code>true</code> if the tail is empty (end of string).</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  Scanner.prototype.eos = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eos</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.tail === <span class="hljs-string">''</span>;
  };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<div class="dox">
<div class="summary">
<p>Tries to match the given regular expression at the current position.
Returns the matched text if it can match, the empty string otherwise.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  Scanner.prototype.scan = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scan</span> (<span class="hljs-params">re</span>) </span>{
    <span class="hljs-keyword">var</span> match = <span class="hljs-keyword">this</span>.tail.match(re);

    <span class="hljs-keyword">if</span> (!match || match.index !== <span class="hljs-number">0</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;

    <span class="hljs-keyword">var</span> string = match[<span class="hljs-number">0</span>];

    <span class="hljs-keyword">this</span>.tail = <span class="hljs-keyword">this</span>.tail.substring(string.length);
    <span class="hljs-keyword">this</span>.pos += string.length;

    <span class="hljs-keyword">return</span> string;
  };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<div class="dox">
<div class="summary">
<p>Skips all text until the given regular expression can be matched. Returns
the skipped string, which is the entire tail if no match can be made.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  Scanner.prototype.scanUntil = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scanUntil</span> (<span class="hljs-params">re</span>) </span>{
    <span class="hljs-keyword">var</span> index = <span class="hljs-keyword">this</span>.tail.search(re), match;

    <span class="hljs-keyword">switch</span> (index) {
      <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:
        match = <span class="hljs-keyword">this</span>.tail;
        <span class="hljs-keyword">this</span>.tail = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
        match = <span class="hljs-string">''</span>;
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">default</span>:
        match = <span class="hljs-keyword">this</span>.tail.substring(<span class="hljs-number">0</span>, index);
        <span class="hljs-keyword">this</span>.tail = <span class="hljs-keyword">this</span>.tail.substring(index);
    }

    <span class="hljs-keyword">this</span>.pos += match.length;

    <span class="hljs-keyword">return</span> match;
  };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<div class="dox">
<div class="summary">
<p>Represents a rendering context by wrapping a view object and
maintaining a reference to the parent context.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Context</span> (<span class="hljs-params">view, parentContext</span>) </span>{
    <span class="hljs-keyword">this</span>.view = view;
    <span class="hljs-keyword">this</span>.cache = { <span class="hljs-string">'.'</span>: <span class="hljs-keyword">this</span>.view };
    <span class="hljs-keyword">this</span>.parent = parentContext;
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<div class="dox">
<div class="summary">
<p>Creates a new context using the given view with this context
as the parent.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  Context.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span> (<span class="hljs-params">view</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Context(view, <span class="hljs-keyword">this</span>);
  };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the value of the given name in this context, traversing
up the context hierarchy if the value is absent in this context's view.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  Context.prototype.lookup = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lookup</span> (<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">var</span> cache = <span class="hljs-keyword">this</span>.cache;

    <span class="hljs-keyword">var</span> value;
    <span class="hljs-keyword">if</span> (cache.hasOwnProperty(name)) {
      value = cache[name];
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>, names, index, lookupHit = <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">while</span> (context) {
        <span class="hljs-keyword">if</span> (name.indexOf(<span class="hljs-string">'.'</span>) &gt; <span class="hljs-number">0</span>) {
          value = context.view;
          names = name.split(<span class="hljs-string">'.'</span>);
          index = <span class="hljs-number">0</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<div class="dox">
<div class="summary">
<p>Using the dot notion path in <code>name</code>, we descend through the
nested objects.</p>
</div>
<div class="body">
<p>To be certain that the lookup has been successful, we have to
check if the last object in the path actually has the property
we are looking for. We store the result in <code>lookupHit</code>.</p>
<p>This is specially necessary for when the value has been set to
<code>undefined</code> and we want to avoid looking up parent contexts.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">while</span> (value != <span class="hljs-literal">null</span> &amp;&amp; index &lt; names.length) {
            <span class="hljs-keyword">if</span> (index === names.length - <span class="hljs-number">1</span>)
              lookupHit = hasProperty(value, names[index]);

            value = value[names[index++]];
          }
        } <span class="hljs-keyword">else</span> {
          value = context.view[name];
          lookupHit = hasProperty(context.view, name);
        }

        <span class="hljs-keyword">if</span> (lookupHit)
          <span class="hljs-keyword">break</span>;

        context = context.parent;
      }

      cache[name] = value;
    }

    <span class="hljs-keyword">if</span> (isFunction(value))
      value = value.call(<span class="hljs-keyword">this</span>.view);

    <span class="hljs-keyword">return</span> value;
  };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<div class="dox">
<div class="summary">
<p>A Writer knows how to take a stream of tokens and render them to a
string, given a context. It also maintains a cache of templates to
avoid the need to parse the same template twice.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Writer</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.cache = {};
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<div class="dox">
<div class="summary">
<p>Clears all cached templates in this writer.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  Writer.prototype.clearCache = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearCache</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.cache = {};
  };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<div class="dox">
<div class="summary">
<p>Parses and caches the given <code>template</code> and returns the array of tokens
that is generated from the parse.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  Writer.prototype.parse = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">template, tags</span>) </span>{
    <span class="hljs-keyword">var</span> cache = <span class="hljs-keyword">this</span>.cache;
    <span class="hljs-keyword">var</span> tokens = cache[template];

    <span class="hljs-keyword">if</span> (tokens == <span class="hljs-literal">null</span>)
      tokens = cache[template] = parseTemplate(template, tags);

    <span class="hljs-keyword">return</span> tokens;
  };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<div class="dox">
<div class="summary">
<p>High-level method that is used to render the given <code>template</code> with
the given <code>view</code>.</p>
</div>
<div class="body">
<p>The optional <code>partials</code> argument may be an object that contains the
names and templates of partials that are used in the template. It may
also be a function that is used to load partial templates on the fly
that takes a single argument: the name of the partial.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  Writer.prototype.render = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span> (<span class="hljs-params">template, view, partials</span>) </span>{
    <span class="hljs-keyword">var</span> tokens = <span class="hljs-keyword">this</span>.parse(template);
    <span class="hljs-keyword">var</span> context = (view <span class="hljs-keyword">instanceof</span> Context) ? view : <span class="hljs-keyword">new</span> Context(view);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.renderTokens(tokens, context, partials, template);
  };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<div class="dox">
<div class="summary">
<p>Low-level method that renders the given array of <code>tokens</code> using
the given <code>context</code> and <code>partials</code>.</p>
</div>
<div class="body">
<p>Note: The <code>originalTemplate</code> is only ever used to extract the portion
of the original template that was contained in a higher-order section.
If the template doesn't use higher-order sections, this argument may
be omitted.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  Writer.prototype.renderTokens = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderTokens</span> (<span class="hljs-params">tokens, context, partials, originalTemplate</span>) </span>{
    <span class="hljs-keyword">var</span> buffer = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">var</span> token, symbol, value;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, numTokens = tokens.length; i &lt; numTokens; ++i) {
      value = <span class="hljs-literal">undefined</span>;
      token = tokens[i];
      symbol = token[<span class="hljs-number">0</span>];

      <span class="hljs-keyword">if</span> (symbol === <span class="hljs-string">'#'</span>) value = <span class="hljs-keyword">this</span>.renderSection(token, context, partials, originalTemplate);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (symbol === <span class="hljs-string">'^'</span>) value = <span class="hljs-keyword">this</span>.renderInverted(token, context, partials, originalTemplate);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (symbol === <span class="hljs-string">'&gt;'</span>) value = <span class="hljs-keyword">this</span>.renderPartial(token, context, partials, originalTemplate);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (symbol === <span class="hljs-string">'&amp;'</span>) value = <span class="hljs-keyword">this</span>.unescapedValue(token, context);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (symbol === <span class="hljs-string">'name'</span>) value = <span class="hljs-keyword">this</span>.escapedValue(token, context);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (symbol === <span class="hljs-string">'text'</span>) value = <span class="hljs-keyword">this</span>.rawValue(token);

      <span class="hljs-keyword">if</span> (value !== <span class="hljs-literal">undefined</span>)
        buffer += value;
    }

    <span class="hljs-keyword">return</span> buffer;
  };

  Writer.prototype.renderSection = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderSection</span> (<span class="hljs-params">token, context, partials, originalTemplate</span>) </span>{
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">var</span> buffer = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">var</span> value = context.lookup(token[<span class="hljs-number">1</span>]);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<p>This function is used to render an arbitrary template
in the current context by higher-order sections.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subRender</span> (<span class="hljs-params">template</span>) </span>{
      <span class="hljs-keyword">return</span> self.render(template, context, partials);
    }

    <span class="hljs-keyword">if</span> (!value) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">if</span> (isArray(value)) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>, valueLength = value.length; j &lt; valueLength; ++j) {
        buffer += <span class="hljs-keyword">this</span>.renderTokens(token[<span class="hljs-number">4</span>], context.push(value[j]), partials, originalTemplate);
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'string'</span> || <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'number'</span>) {
      buffer += <span class="hljs-keyword">this</span>.renderTokens(token[<span class="hljs-number">4</span>], context.push(value), partials, originalTemplate);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isFunction(value)) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originalTemplate !== <span class="hljs-string">'string'</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Cannot use higher-order sections without the original template'</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-32" id="section-32"></a>
</div>
<p>Extract the portion of the original template that the section contains.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      value = value.call(context.view, originalTemplate.slice(token[<span class="hljs-number">3</span>], token[<span class="hljs-number">5</span>]), subRender);

      <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>)
        buffer += value;
    } <span class="hljs-keyword">else</span> {
      buffer += <span class="hljs-keyword">this</span>.renderTokens(token[<span class="hljs-number">4</span>], context, partials, originalTemplate);
    }
    <span class="hljs-keyword">return</span> buffer;
  };

  Writer.prototype.renderInverted = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderInverted</span> (<span class="hljs-params">token, context, partials, originalTemplate</span>) </span>{
    <span class="hljs-keyword">var</span> value = context.lookup(token[<span class="hljs-number">1</span>]);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-33" id="section-33"></a>
</div>
<p>Use JavaScript's definition of falsy. Include empty arrays.
See https://github.com/janl/mustache.js/issues/186</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (!value || (isArray(value) &amp;&amp; value.length === <span class="hljs-number">0</span>))
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.renderTokens(token[<span class="hljs-number">4</span>], context, partials, originalTemplate);
  };

  Writer.prototype.renderPartial = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderPartial</span> (<span class="hljs-params">token, context, partials</span>) </span>{
    <span class="hljs-keyword">if</span> (!partials) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">var</span> value = isFunction(partials) ? partials(token[<span class="hljs-number">1</span>]) : partials[token[<span class="hljs-number">1</span>]];
    <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.renderTokens(<span class="hljs-keyword">this</span>.parse(value), context, partials, value);
  };

  Writer.prototype.unescapedValue = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unescapedValue</span> (<span class="hljs-params">token, context</span>) </span>{
    <span class="hljs-keyword">var</span> value = context.lookup(token[<span class="hljs-number">1</span>]);
    <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>)
      <span class="hljs-keyword">return</span> value;
  };

  Writer.prototype.escapedValue = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">escapedValue</span> (<span class="hljs-params">token, context</span>) </span>{
    <span class="hljs-keyword">var</span> value = context.lookup(token[<span class="hljs-number">1</span>]);
    <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>)
      <span class="hljs-keyword">return</span> mustache.escape(value);
  };

  Writer.prototype.rawValue = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rawValue</span> (<span class="hljs-params">token</span>) </span>{
    <span class="hljs-keyword">return</span> token[<span class="hljs-number">1</span>];
  };

  mustache.name = <span class="hljs-string">'mustache.js'</span>;
  mustache.version = <span class="hljs-string">'2.3.0'</span>;
  mustache.tags = [ <span class="hljs-string">'{{'</span>, <span class="hljs-string">'}}'</span> ];

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-34" id="section-34"></a>
</div>
<p>All high-level mustache.* functions use this writer.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> defaultWriter = <span class="hljs-keyword">new</span> Writer();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-35" id="section-35"></a>
</div>
<div class="dox">
<div class="summary">
<p>Clears all cached templates in the default writer.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  mustache.clearCache = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearCache</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> defaultWriter.clearCache();
  };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-36" id="section-36"></a>
</div>
<div class="dox">
<div class="summary">
<p>Parses and caches the given template in the default writer and returns the
array of tokens it contains. Doing this ahead of time avoids the need to
parse templates on the fly as they are rendered.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  mustache.parse = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">template, tags</span>) </span>{
    <span class="hljs-keyword">return</span> defaultWriter.parse(template, tags);
  };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-37" id="section-37"></a>
</div>
<div class="dox">
<div class="summary">
<p>Renders the <code>template</code> with the given <code>view</code> and <code>partials</code> using the
default writer.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  mustache.render = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span> (<span class="hljs-params">template, view, partials</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> template !== <span class="hljs-string">'string'</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Invalid template! Template should be a "string" '</span> +
                          <span class="hljs-string">'but "'</span> + typeStr(template) + <span class="hljs-string">'" was given as the first '</span> +
                          <span class="hljs-string">'argument for mustache#render(template, view, partials)'</span>);
    }

    <span class="hljs-keyword">return</span> defaultWriter.render(template, view, partials);
  };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-38" id="section-38"></a>
</div>
<p>This is here for backwards compatibility with 0.4.x.,</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-comment">/*eslint-disable */</span> <span class="hljs-comment">// eslint wants camel cased function name</span>
  mustache.to_html = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">to_html</span> (<span class="hljs-params">template, view, partials, send</span>) </span>{
    <span class="hljs-comment">/*eslint-enable*/</span>

    <span class="hljs-keyword">var</span> result = mustache.render(template, view, partials);

    <span class="hljs-keyword">if</span> (isFunction(send)) {
      send(result);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> result;
    }
  };

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-39" id="section-39"></a>
</div>
<p>Export the escaping function so that the user may override it.
See https://github.com/janl/mustache.js/issues/244</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  mustache.escape = escapeHtml;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-40" id="section-40"></a>
</div>
<p>Export these mainly for testing, but also for advanced usage.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  mustache.Scanner = Scanner;
  mustache.Context = Context;
  mustache.Writer = Writer;

  <span class="hljs-keyword">return</span> mustache;
}));

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
