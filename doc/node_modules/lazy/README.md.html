<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/lazy/README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#lazy-lists-for-node">Lazy lists for node</a>
      </div>

      <div class="heading h1">
        <a href="#table-of-contents">Table of contents:</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><div class="pilwrap" id="lazy-lists-for-node">
  <h1>
    <a href="#lazy-lists-for-node" name="lazy-lists-for-node" class="pilcrow"></a>
Lazy lists for node
  </h1>
</div>
<div class="pilwrap" id="table-of-contents">
  <h1>
    <a href="#table-of-contents" name="table-of-contents" class="pilcrow"></a>
Table of contents:
  </h1>
</div>
<p><a href="#Introduction.html">Introduction</a></p>
<p><a href="#Documentation.html">Documentation</a></p>
<a name="Introduction" />
# Introduction
Lazy comes really handy when you need to treat a stream of events like a list.
The best use case currently is returning a lazy list from an asynchronous
function, and having data pumped into it via events. In asynchronous
programming you can't just return a regular list because you don't yet have
data for it. The usual solution so far has been to provide a callback that gets
called when the data is available. But doing it this way you lose the power of
chaining functions and creating pipes, which leads to not that nice interfaces.
(See the 2nd example below to see how it improved the interface in one of my
modules.)
<p>Check out this toy example, first you create a Lazy object:</p>
<pre><code class="javascript">    <span class="hljs-keyword">var</span> Lazy = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lazy'</span>);

    <span class="hljs-keyword">var</span> lazy = <span class="hljs-keyword">new</span> Lazy;
    lazy
      .filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
        <span class="hljs-keyword">return</span> item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>
      })
      .take(<span class="hljs-number">5</span>)
      .map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
        <span class="hljs-keyword">return</span> item*<span class="hljs-number">2</span>;
      })
      .join(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xs</span>) </span>{
        <span class="hljs-built_in">console</span>.log(xs);
      });
</code></pre>
<p>This code says that 'lazy' is going to be a lazy list that filters even
numbers, takes first five of them, then multiplies all of them by 2, and then
calls the join function (think of join as in threads) on the final list.</p>
<p>And now you can emit 'data' events with data in them at some point later,</p>
<pre><code class="javascript">    [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
      lazy.emit(<span class="hljs-string">'data'</span>, x);
    });
</code></pre>
<p>The output will be produced by the 'join' function, which will output the
expected [0, 4, 8, 12, 16].</p>
<p>And here is a real-world example. Some time ago I wrote a hash database for
node.js called node-supermarket (think of key-value store except greater). Now
it had a similar interface as a list, you could .forEach on the stored
elements, .filter them, etc. But being asynchronous in nature it lead to the
following code, littered with callbacks and temporary lists:</p>
<pre><code class="javascript">    <span class="hljs-keyword">var</span> Store = <span class="hljs-built_in">require</span>(<span class="hljs-string">'supermarket'</span>);

    <span class="hljs-keyword">var</span> db = <span class="hljs-keyword">new</span> Store({ <span class="hljs-attr">filename</span> : <span class="hljs-string">'users.db'</span>, <span class="hljs-attr">json</span> : <span class="hljs-literal">true</span> });

    <span class="hljs-keyword">var</span> users_over_20 = [];
    db.filter(
      <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">user, meta</span>) </span>{
        <span class="hljs-comment">// predicate function</span>
        <span class="hljs-keyword">return</span> meta.age &gt; <span class="hljs-number">20</span>;
      },
      <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, user, meta</span>) </span>{
        <span class="hljs-comment">// function that gets executed when predicate is true</span>
        <span class="hljs-keyword">if</span> (users_over_20.length &lt; <span class="hljs-number">5</span>)
          users_over_20.push(meta);
      },
      <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// done function, called when all records have been filtered</span>

        <span class="hljs-comment">// now do something with users_over_20</span>
      }
    )
</code></pre>
<p>This code selects first five users who are over 20 years old and stores them
in users_over_20.</p>
<p>But now we changed the node-supermarket interface to return lazy lists, and
the code became:</p>
<pre><code class="javascript">    <span class="hljs-keyword">var</span> Store = <span class="hljs-built_in">require</span>(<span class="hljs-string">'supermarket'</span>);

    <span class="hljs-keyword">var</span> db = <span class="hljs-keyword">new</span> Store({ <span class="hljs-attr">filename</span> : <span class="hljs-string">'users.db'</span>, <span class="hljs-attr">json</span> : <span class="hljs-literal">true</span> });

    db.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">user, meta</span>) </span>{
        <span class="hljs-keyword">return</span> meta.age &gt; <span class="hljs-number">20</span>;
      })
      .take(<span class="hljs-number">5</span>)
      .join(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xs</span>) </span>{
        <span class="hljs-comment">// xs contains the first 5 users who are over 20!</span>
      });
</code></pre>
<p>This is so much nicer!</p>
<p>Here is the latest feature: .lines. Given a stream of data that has \n's in it,
.lines converts that into a list of lines.</p>
<p>Here is an example from node-iptables that I wrote the other week,</p>
<pre><code class="javascript">    <span class="hljs-keyword">var</span> Lazy = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lazy'</span>);
    <span class="hljs-keyword">var</span> spawn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).spawn;
    <span class="hljs-keyword">var</span> iptables = spawn(<span class="hljs-string">'iptables'</span>, [<span class="hljs-string">'-L'</span>, <span class="hljs-string">'-n'</span>, <span class="hljs-string">'-v'</span>]);

    Lazy(iptables.stdout)
        .lines
        .map(<span class="hljs-built_in">String</span>)
        .skip(<span class="hljs-number">2</span>) <span class="hljs-comment">// skips the two lines that are iptables header</span>
        .map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">line</span>) </span>{
            <span class="hljs-comment">// packets, bytes, target, pro, opt, in, out, src, dst, opts</span>
            <span class="hljs-keyword">var</span> fields = line.trim().split(<span class="hljs-regexp">/\s+/</span>, <span class="hljs-number">9</span>);
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">parsed</span> : {
                    <span class="hljs-attr">packets</span> : fields[<span class="hljs-number">0</span>],
                    <span class="hljs-attr">bytes</span> : fields[<span class="hljs-number">1</span>],
                    <span class="hljs-attr">target</span> : fields[<span class="hljs-number">2</span>],
                    <span class="hljs-attr">protocol</span> : fields[<span class="hljs-number">3</span>],
                    <span class="hljs-attr">opt</span> : fields[<span class="hljs-number">4</span>],
                    <span class="hljs-attr">in</span> : fields[<span class="hljs-number">5</span>],
                    <span class="hljs-attr">out</span> : fields[<span class="hljs-number">6</span>],
                    <span class="hljs-attr">src</span> : fields[<span class="hljs-number">7</span>],
                    <span class="hljs-attr">dst</span> : fields[<span class="hljs-number">8</span>]
                },
                <span class="hljs-attr">raw</span> : line.trim()
            };
        });
</code></pre>
<p>This example takes the <code>iptables -L -n -v</code> command and uses .lines on its output.
Then it .skip's two lines from input and maps a function on all other lines that
creates a data structure from the output.</p>
<a name="Documentation" />
# Documentation
<p>Supports the following operations:</p>
<ul>
<li>lazy.filter(f)</li>
<li>lazy.forEach(f)</li>
<li>lazy.map(f)</li>
<li>lazy.take(n)</li>
<li>lazy.takeWhile(f)</li>
<li>lazy.bucket(init, f)</li>
<li>lazy.lines</li>
<li>lazy.sum(f)</li>
<li>lazy.product(f)</li>
<li>lazy.foldr(op, i, f)</li>
<li>lazy.skip(n)</li>
<li>lazy.head(f)</li>
<li>lazy.tail(f)</li>
<li>lazy.join(f)</li>
</ul>
<p>The Lazy object itself has a .range property for generating all the possible ranges.</p>
<p>Here are several examples:</p>
<ul>
<li>Lazy.range('10..') - infinite range starting from 10</li>
<li>Lazy.range('(10..') - infinite range starting from 11</li>
<li>Lazy.range(10) - range from 0 to 9</li>
<li>Lazy.range(-10, 10) - range from -10 to 9 (-10, -9, ... 0, 1, ... 9)</li>
<li>Lazy.range(-10, 10, 2) - range from -10 to 8, skipping every 2nd element (-10, -8, ... 0, 2, 4, 6, 8)</li>
<li>Lazy.range(10, 0, 2) - reverse range from 10 to 1, skipping every 2nd element (10, 8, 6, 4, 2)</li>
<li>Lazy.range(10, 0) - reverse range from 10 to 1</li>
<li>Lazy.range('5..50') - range from 5 to 49</li>
<li>Lazy.range('50..44') - range from 50 to 45</li>
<li>Lazy.range('1,1.1..4') - range from 1 to 4 with increment of 0.1 (1, 1.1, 1.2, ... 3.9)</li>
<li>Lazy.range('4,3.9..1') - reverse range from 4 to 1 with decerement of 0.1</li>
<li>Lazy.range('[1..10]') - range from 1 to 10 (all inclusive)</li>
<li>Lazy.range('[10..1]') - range from 10 to 1 (all inclusive)</li>
<li>Lazy.range('[1..10)') - range grom 1 to 9</li>
<li>Lazy.range('[10..1)') - range from 10 to 2</li>
<li>Lazy.range('(1..10]') - range from 2 to 10</li>
<li>Lazy.range('(10..1]') - range from 9 to 1</li>
<li>Lazy.range('(1..10)') - range from 2 to 9</li>
<li>Lazy.range('[5,10..50]') - range from 5 to 50 with a step of 5 (all inclusive)</li>
</ul>
<p>Then you can use other lazy functions on these ranges.</p>
</div>
  </div>
</body>
</html>
