<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/double-ended-queue/README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>
<p>#Introduction</p>
<p>Extremely fast <a href="http://en.wikipedia.org/wiki/Double-ended_queue">double-ended queue</a> implementation. Double-ended queue can also be used as a:</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Stack_(abstract_data_type)">Stack</a></li>
<li><a href="http://en.wikipedia.org/wiki/Queue_(data_structure)">Queue</a></li>
</ul>
<p>The implementation is GC and CPU cache friendly <a href="http://en.wikipedia.org/wiki/Circular_buffer">circular buffer</a>. <a href="#performance.html">It will run circles around any &quot;linked list&quot; implementation</a>.</p>
<p>Every queue operation is done in constant <code>O(1)</code> - including random access from <code>.get()</code>.</p>
<p>#Topics</p>
<ul>
<li><a href="#quick-start.html">Quick start</a></li>
<li><a href="#why-not-use-an-array.html">Why not use an Array?</a></li>
<li><a href="#using-double-ended-queue-as-a-normal-queue.html">Using double-ended queue as a normal queue</a></li>
<li><a href="#api.html">API reference and examples</a></li>
<li><a href="#performance.html">Performance</a></li>
</ul>
<p>#Quick start</p>
<pre><code>npm install double-ended-queue
</code></pre>
<pre><code class="js"><span class="hljs-keyword">var</span> Deque = <span class="hljs-built_in">require</span>(<span class="hljs-string">"double-ended-queue"</span>);

<span class="hljs-keyword">var</span> deque = <span class="hljs-keyword">new</span> Deque([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]);
deque.shift(); <span class="hljs-comment">//1</span>
deque.pop(); <span class="hljs-comment">//4</span>
</code></pre>
<p>#Why not use an Array?</p>
<p>Arrays take linear <code>O(N)</code> time to do <code>shift</code> and <code>unshift</code> operations. That means in theory that an array with 1000 items is 1000x slower to do those operations than a deque with 1000 items. 10000x slower with 10000 items and so on.</p>
<p>V8 implements <a href="https://code.google.com/p/v8/issues/detail?id=3059">a trick for small arrays</a> where these operations are done in constant time, however even with this trick deque is still 4x faster.</p>
<p>But arrays use &quot;native&quot; methods, they must be faster!</p>
<p>In V8, there is almost no advantage for a method to be a built-in. In fact many times built-ins are at a severe disadvantage of having to implement far more complex semantics than is actually needed in practice. For example, sparse array handling punishes almost every built-in array method even though nobody uses sparse arrays as is evidenced by the popularity of the underscore library which doesn't handle sparse arrays in the same way across different browsers.</p>
<p>#Using double-ended queue as a normal queue</p>
<p>Queue is a more commonly needed data structure however a separate implementation does not provide any advantage in terms of performance. Aliases are provided specifically for the queue use-case. You may use <code>.enqueue(items...)</code> to enqueue item(s) and <code>.dequeue()</code> to dequeue an item.</p>
<p>#API</p>
<ul>
<li><a href="#new-deque---deque.html"><code>new Deque()</code></a></li>
<li><a href="#new-dequearray-items---deque.html"><code>new Deque(Array items)</code></a></li>
<li><a href="#new-dequeint-capacity---deque.html"><code>new Deque(int capacity)</code></a></li>
<li><a href="#pushdynamic-items---int.html"><code>push(dynamic items...)</code></a></li>
<li><a href="#unshiftdynamic-items---int.html"><code>unshift(dynamic items...)</code></a></li>
<li><a href="#pop---dynamic.html"><code>pop()</code></a></li>
<li><a href="#shift---dynamic.html"><code>shift()</code></a></li>
<li><a href="#toarray---array.html"><code>toArray()</code></a></li>
<li><a href="#peekback---dynamic.html"><code>peekBack()</code></a></li>
<li><a href="#peekfront---dynamic.html"><code>peekFront()</code></a></li>
<li><a href="#getint-index---dynamic.html"><code>get(int index)</code></a></li>
<li><a href="#isempty---boolean.html"><code>isEmpty()</code></a></li>
<li><a href="#clear---void.html"><code>clear()</code></a></li>
</ul>
<p>#####<code>new Deque()</code> -&gt; <code>Deque</code></p>
<p>Creates an empty double-ended queue with initial capacity of 16. If you know the optimal size before-hand, use <a href="#new-dequeint-capacity---deque.html"><code>new Deque(int capacity)</code></a>.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> deque = <span class="hljs-keyword">new</span> Deque();
deque.push(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
deque.shift(); <span class="hljs-comment">//1</span>
deque.pop(); <span class="hljs-comment">//3</span>
</code></pre>
<hr>
<p>#####<code>new Deque(Array items)</code> -&gt; <code>Deque</code></p>
<p>Creates a double-ended queue from <code>items</code>.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> deque = <span class="hljs-keyword">new</span> Deque([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]);
deque.shift(); <span class="hljs-comment">//1</span>
deque.pop(); <span class="hljs-comment">//4</span>
</code></pre>
<hr>
<p>#####<code>new Deque(int capacity)</code> -&gt; <code>Deque</code></p>
<p>Creates an empty double-ended queue with the given <code>capacity</code>. <code>Capacity</code> should be the maximum amount of items the queue will hold at a given time.</p>
<p>The reason to give an initial capacity is to avoid potentially expensive resizing operations at runtime.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> deque = <span class="hljs-keyword">new</span> Deque(<span class="hljs-number">100</span>);
deque.push(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
deque.shift(); <span class="hljs-comment">//1</span>
deque.pop(); <span class="hljs-comment">//3</span>
</code></pre>
<hr>
<p>#####<code>push(dynamic items...)</code> -&gt; <code>int</code></p>
<p>Push items to the back of this queue. Returns the amount of items currently in the queue after the operation.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> deque = <span class="hljs-keyword">new</span> Deque();
deque.push(<span class="hljs-number">1</span>);
deque.pop(); <span class="hljs-comment">//1</span>
deque.push(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
deque.shift(); <span class="hljs-comment">//1</span>
deque.shift(); <span class="hljs-comment">//2</span>
deque.shift(); <span class="hljs-comment">//3</span>
</code></pre>
<p><strong>Aliases:</strong> <code>enqueue</code>, <code>insertBack</code></p>
<hr>
<p>#####<code>unshift(dynamic items...)</code> -&gt; <code>int</code></p>
<p>Unshift items to the front of this queue. Returns the amount of items currently in the queue after the operation.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> deque = <span class="hljs-keyword">new</span> Deque([<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
deque.unshift(<span class="hljs-number">1</span>);
deque.toString(); <span class="hljs-comment">//"1,2,3"</span>
deque.unshift(<span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);
deque.toString(); <span class="hljs-comment">//"-2,-1,0,1,2,3"</span>
</code></pre>
<p><strong>Aliases:</strong> <code>insertFront</code></p>
<hr>
<p>#####<code>pop()</code> -&gt; <code>dynamic</code></p>
<p>Pop off the item at the back of this queue.</p>
<p>Note: The item will be removed from the queue. If you simply want to see what's at the back of the queue use <a href="#peekback---dynamic.html"><code>peekBack()</code></a> or <a href="#getint-index---dynamic.html"><code>.get(-1)</code></a>.</p>
<p>If the queue is empty, <code>undefined</code> is returned. If you need to differentiate between <code>undefined</code> values in the queue and <code>pop()</code> return value -
check the queue <code>.length</code> before popping.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> deque = <span class="hljs-keyword">new</span> Deque([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
deque.pop(); <span class="hljs-comment">//3</span>
deque.pop(); <span class="hljs-comment">//2</span>
deque.pop(); <span class="hljs-comment">//1</span>
deque.pop(); <span class="hljs-comment">//undefined</span>
</code></pre>
<p><strong>Aliases:</strong> <code>removeBack</code></p>
<hr>
<p>#####<code>shift()</code> -&gt; <code>dynamic</code></p>
<p>Shifts off the item at the front of this queue.</p>
<p>Note: The item will be removed from the queue. If you simply want to see what's at the front of the queue use <a href="#peekfront---dynamic.html"><code>peekFront()</code></a> or <a href="#getint-index---dynamic.html"><code>.get(0)</code></a>.</p>
<p>If the queue is empty, <code>undefined</code> is returned. If you need to differentiate between <code>undefined</code> values in the queue and <code>shift()</code> return value -
check the queue <code>.length</code> before shifting.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> deque = <span class="hljs-keyword">new</span> Deque([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
deque.shift(); <span class="hljs-comment">//1</span>
deque.shift(); <span class="hljs-comment">//2</span>
deque.shift(); <span class="hljs-comment">//3</span>
deque.shift(); <span class="hljs-comment">//undefined</span>
</code></pre>
<p><strong>Aliases:</strong> <code>removeFront</code>, <code>dequeue</code></p>
<hr>
<p>#####<code>toArray()</code> -&gt; <code>Array</code></p>
<p>Returns the items in the queue as an array. Starting from the item in the front of the queue and ending to the item at the back of the queue.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> deque = <span class="hljs-keyword">new</span> Deque([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
deque.push(<span class="hljs-number">4</span>);
deque.unshift(<span class="hljs-number">0</span>);
deque.toArray(); <span class="hljs-comment">//[0,1,2,3,4]</span>
</code></pre>
<p><strong>Aliases:</strong> <code>toJSON</code></p>
<hr>
<p>#####<code>peekBack()</code> -&gt; <code>dynamic</code></p>
<p>Returns the item that is at the back of this queue without removing it.</p>
<p>If the queue is empty, <code>undefined</code> is returned.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> deque = <span class="hljs-keyword">new</span> Deque([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
deque.push(<span class="hljs-number">4</span>);
deque.peekBack(); <span class="hljs-comment">//4</span>
</code></pre>
<hr>
<p>#####<code>peekFront()</code> -&gt; <code>dynamic</code></p>
<p>Returns the item that is at the front of this queue without removing it.</p>
<p>If the queue is empty, <code>undefined</code> is returned.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> deque = <span class="hljs-keyword">new</span> Deque([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
deque.push(<span class="hljs-number">4</span>);
deque.peekFront(); <span class="hljs-comment">//1</span>
</code></pre>
<hr>
<p>#####<code>get(int index)</code> -&gt; <code>dynamic</code></p>
<p>Returns the item that is at the given <code>index</code> of this queue without removing it.</p>
<p>The index is zero-based, so <code>.get(0)</code> will return the item that is at the front, <code>.get(1)</code> will return
the item that comes after and so on.</p>
<p>The index can be negative to read items at the back of the queue. <code>.get(-1)</code> returns the item that is at the back of the queue,
<code>.get(-2)</code> will return the item that comes before and so on.</p>
<p>Returns <code>undefined</code> if <code>index</code> is not a valid index into the queue.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> deque = <span class="hljs-keyword">new</span> Deque([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
deque.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//1</span>
deque.get(<span class="hljs-number">1</span>); <span class="hljs-comment">//2</span>
deque.get(<span class="hljs-number">2</span>); <span class="hljs-comment">//3</span>

deque.get(<span class="hljs-number">-1</span>); <span class="hljs-comment">//3</span>
deque.get(<span class="hljs-number">-2</span>); <span class="hljs-comment">//2</span>
deque.get(<span class="hljs-number">-3</span>); <span class="hljs-comment">//1</span>
</code></pre>
<p><strong>Note</strong>: Even though indexed accessor (e.g. <code>queue[0]</code>) could <em>appear</em> to return a correct value <em>sometimes</em>, this is completely unreliable. The numeric slots
of the deque object are internally used as an optimization and have no meaningful order or meaning to outside. Always use <code>.get()</code>.</p>
<p><strong>Note</strong>: The implementation has O(1) random access using <code>.get()</code>.</p>
<hr>
<p>#####<code>isEmpty()</code> -&gt; <code>boolean</code></p>
<p>Return <code>true</code> if this queue is empty, <code>false</code> otherwise.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> deque = <span class="hljs-keyword">new</span> Deque();
deque.isEmpty(); <span class="hljs-comment">//true</span>
deque.push(<span class="hljs-number">1</span>);
deque.isEmpty(); <span class="hljs-comment">//false</span>
</code></pre>
<hr>
<p>#####<code>clear()</code> -&gt; <code>void</code></p>
<p>Remove all items from this queue. Does not change the queue's capacity.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> deque = <span class="hljs-keyword">new</span> Deque([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
deque.toString(); <span class="hljs-comment">//"1,2,3"</span>
deque.clear();
deque.toString(); <span class="hljs-comment">//""</span>
</code></pre>
<hr>
<p>#Performance</p>
<p>Clone the repo and <code>npm install</code>. Then run the <code>bench</code> script.</p>
<p>##1000 items in the queue</p>
<pre><code>double-ended-queue x 15,532,714 ops/sec ±0.19% (96 runs sampled)
built-in array x 6,501,398 ops/sec ±0.87% (95 runs sampled)
node-deque x 2,938,068 ops/sec ±3.50% (68 runs sampled)
</code></pre>
<p>##2 million items in the queue</p>
<pre><code>double-ended-queue x 14,425,547 ops/sec ±0.17% (94 runs sampled)
node-deque x 2,815,628 ops/sec ±10.56% (76 runs sampled)
built-in array x 19.23 ops/sec ±0.35% (51 runs sampled)
</code></pre>
<p>Noteworthy is just how bad the degradation can be for built-in array when V8 cannot use the trick.</p>
</div>
  </div>
</body>
</html>
