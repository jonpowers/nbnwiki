<!DOCTYPE html>
<html>
<head>
  <title>LIMITS.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/node-fetch/LIMITS.md";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#known-differences">Known differences</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><div class="pilwrap" id="known-differences">
  <h1>
    <a href="#known-differences" name="known-differences" class="pilcrow"></a>
Known differences
  </h1>
</div>
<p><em>As of 1.x release</em></p>
<ul>
<li>
<p>Topics such as Cross-Origin, Content Security Policy, Mixed Content, Service Workers are ignored, given our server-side context.</p>
</li>
<li>
<p>URL input must be an absolute URL, using either <code>http</code> or <code>https</code> as scheme.</p>
</li>
<li>
<p>On the upside, there are no forbidden headers, and <code>res.url</code> contains the final url when following redirects.</p>
</li>
<li>
<p>For convenience, <code>res.body</code> is a transform stream, so decoding can be handled independently.</p>
</li>
<li>
<p>Similarly, <code>req.body</code> can either be a string, a buffer or a readable stream.</p>
</li>
<li>
<p>Also, you can handle rejected fetch requests through checking <code>err.type</code> and <code>err.code</code>.</p>
</li>
<li>
<p>Only support <code>res.text()</code>, <code>res.json()</code>, <code>res.buffer()</code> at the moment, until there are good use-cases for blob/arrayBuffer.</p>
</li>
<li>
<p>There is currently no built-in caching, as server-side caching varies by use-cases.</p>
</li>
<li>
<p>Current implementation lacks server-side cookie store, you will need to extract <code>Set-Cookie</code> headers manually.</p>
</li>
<li>
<p>If you are using <code>res.clone()</code> and writing an isomorphic app, note that stream on Node.js have a smaller internal buffer size (16Kb, aka <code>highWaterMark</code>) from client-side browsers (&gt;1Mb, not consistent across browsers).</p>
</li>
<li>
<p>ES6 features such as <code>headers.entries()</code> are missing at the moment, but you can use <code>headers.raw()</code> to retrieve the raw headers object.</p>
</li>
</ul>
</div>
  </div>
</body>
</html>
