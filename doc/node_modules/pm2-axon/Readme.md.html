<!DOCTYPE html>
<html>
<head>
  <title>Readme.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/pm2-axon/Readme.md";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#axon">Axon</a>
      </div>

      <div class="heading h2">
        <a href="#installation">Installation</a>
      </div>

      <div class="heading h2">
        <a href="#features">Features</a>
      </div>

      <div class="heading h2">
        <a href="#events">Events</a>
      </div>

      <div class="heading h2">
        <a href="#patterns">Patterns</a>
      </div>

      <div class="heading h2">
        <a href="#mixed-argument-types">Mixed argument types</a>
      </div>

      <div class="heading h2">
        <a href="#push-pull">Push / Pull</a>
      </div>

      <div class="heading h2">
        <a href="#pub-sub">Pub / Sub</a>
      </div>

      <div class="heading h2">
        <a href="#req-rep">Req / Rep</a>
      </div>

      <div class="heading h2">
        <a href="#pubemitter-subemitter">PubEmitter / SubEmitter</a>
      </div>

      <div class="heading h2">
        <a href="#socket-options">Socket Options</a>
      </div>

      <div class="heading h2">
        <a href="#binding-connecting">Binding / Connecting</a>
      </div>

      <div class="heading h2">
        <a href="#protocol">Protocol</a>
      </div>

      <div class="heading h2">
        <a href="#performance">Performance</a>
      </div>

      <div class="heading h2">
        <a href="#whats-it-good-for">What&#39;s it good for?</a>
      </div>

      <div class="heading h2">
        <a href="#running-tests">Running tests</a>
      </div>

      <div class="heading h2">
        <a href="#authors">Authors</a>
      </div>

      <div class="heading h2">
        <a href="#links">Links</a>
      </div>

      <div class="heading h2">
        <a href="#license">License</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><div class="pilwrap" id="axon">
  <h1>
    <a href="#axon" name="axon" class="pilcrow"></a>
Axon
  </h1>
</div>
<p>Axon is a message-oriented socket library for node.js heavily inspired by zeromq. For a light-weight
UDP alternative you may be interested in <a href="https://github.com/visionmedia/punt">punt</a>.</p>
<p><a href="https://travis-ci.org/unitech/pm2-axon"><img src="https://travis-ci.org/unitech/pm2-axon.png" alt="Build Status"></a></p>
<div class="pilwrap" id="installation">
  <h2>
    <a href="#installation" name="installation" class="pilcrow"></a>
Installation
  </h2>
</div>
<pre><code>$ npm install axon
</code></pre>
<div class="pilwrap" id="features">
  <h2>
    <a href="#features" name="features" class="pilcrow"></a>
Features
  </h2>
</div>
<ul>
<li>message oriented</li>
<li>automated reconnection</li>
<li>light-weight wire protocol</li>
<li>mixed-type arguments (strings, objects, buffers, etc)</li>
<li>unix domain socket support</li>
<li>fast (~800 mb/s ~500,000 messages/s)</li>
</ul>
<div class="pilwrap" id="events">
  <h2>
    <a href="#events" name="events" class="pilcrow"></a>
Events
  </h2>
</div>
<ul>
<li><code>close</code> when server or connection is closed</li>
<li><code>error</code> (err) when an un-handled socket error occurs</li>
<li><code>ignored error</code> (err) when an axon-handled socket error occurs, but is ignored</li>
<li><code>socket error</code> (err) emitted regardless of handling, for logging purposes</li>
<li><code>reconnect attempt</code> when a reconnection attempt is made</li>
<li><code>connect</code> when connected to the peer, or a peer connection is accepted</li>
<li><code>disconnect</code> when an accepted peer disconnects</li>
<li><code>bind</code> when the server is bound</li>
<li><code>drop</code> (msg) when a message is dropped due to the HWM</li>
<li><code>flush</code> (msgs) queued when messages are flushed on connection</li>
</ul>
<div class="pilwrap" id="patterns">
  <h2>
    <a href="#patterns" name="patterns" class="pilcrow"></a>
Patterns
  </h2>
</div>
<ul>
<li>push / pull</li>
<li>pub / sub</li>
<li>req / rep</li>
<li>pub-emitter / sub-emitter</li>
</ul>
<div class="pilwrap" id="mixed-argument-types">
  <h2>
    <a href="#mixed-argument-types" name="mixed-argument-types" class="pilcrow"></a>
Mixed argument types
  </h2>
</div>
<p>Backed by <a href="https://github.com/visionmedia/node-amp-message">node-amp-message</a>
you may pass strings, objects, and buffers as arguments.</p>
<pre><code class="js">push.send(<span class="hljs-string">'image'</span>, { <span class="hljs-attr">w</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">h</span>: <span class="hljs-number">200</span> }, imageBuffer);
pull.on(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, size, img</span>)</span>{});
</code></pre>
<div class="pilwrap" id="push-pull">
  <h2>
    <a href="#push-pull" name="push-pull" class="pilcrow"></a>
Push / Pull
  </h2>
</div>
<p><code>PushSocket</code>s distribute messages round-robin:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> axon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'axon'</span>);
<span class="hljs-keyword">var</span> sock = axon.socket(<span class="hljs-string">'push'</span>);

sock.bind(<span class="hljs-number">3000</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'push server started'</span>);

setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  sock.send(<span class="hljs-string">'hello'</span>);
}, <span class="hljs-number">150</span>);
</code></pre>
<p>Receiver of <code>PushSocket</code> messages:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> axon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'axon'</span>);
<span class="hljs-keyword">var</span> sock = axon.socket(<span class="hljs-string">'pull'</span>);

sock.connect(<span class="hljs-number">3000</span>);

sock.on(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>)</span>{
  <span class="hljs-built_in">console</span>.log(msg.toString());
});
</code></pre>
<p>Both <code>PushSocket</code>s and <code>PullSocket</code>s may <code>.bind()</code> or <code>.connect()</code>. In the
following configuration the push socket is bound and pull &quot;workers&quot; connect
to it to receive work:</p>
<p><img src="http://f.cl.ly/items/473u3m1a0k1i0J0I3s04/ss-push.png" alt="push bind"></p>
<p>This configuration shows the inverse, where workers connect to a &quot;sink&quot;
to push results:</p>
<p><img src="http://f.cl.ly/items/3Y0j2v153Q0l1r373i0H/ss-pull.png" alt="pull bind"></p>
<div class="pilwrap" id="pub-sub">
  <h2>
    <a href="#pub-sub" name="pub-sub" class="pilcrow"></a>
Pub / Sub
  </h2>
</div>
<p><code>PubSocket</code>s send messages to all subscribers without queueing. This is an
important difference when compared to a <code>PushSocket</code>, where the delivery of
messages will be queued during disconnects and sent again upon the next connection.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> axon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'axon'</span>);
<span class="hljs-keyword">var</span> sock = axon.socket(<span class="hljs-string">'pub'</span>);

sock.bind(<span class="hljs-number">3000</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'pub server started'</span>);

setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  sock.send(<span class="hljs-string">'hello'</span>);
}, <span class="hljs-number">500</span>);
</code></pre>
<p><code>SubSocket</code> simply receives any messages from a <code>PubSocket</code>:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> axon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'axon'</span>);
<span class="hljs-keyword">var</span> sock = axon.socket(<span class="hljs-string">'sub'</span>);

sock.connect(<span class="hljs-number">3000</span>);

sock.on(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>)</span>{
  <span class="hljs-built_in">console</span>.log(msg.toString());
});
</code></pre>
<p><code>SubSocket</code>s may optionally <code>.subscribe()</code> to one or more &quot;topics&quot; (the first multipart value),
using string patterns or regular expressions:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> axon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'axon'</span>);
<span class="hljs-keyword">var</span> sock = axon.socket(<span class="hljs-string">'sub'</span>);

sock.connect(<span class="hljs-number">3000</span>);
sock.subscribe(<span class="hljs-string">'user:login'</span>);
sock.subscribe(<span class="hljs-string">'upload:*:progress'</span>);

sock.on(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">topic, msg</span>)</span>{

});
</code></pre>
<div class="pilwrap" id="req-rep">
  <h2>
    <a href="#req-rep" name="req-rep" class="pilcrow"></a>
Req / Rep
  </h2>
</div>
<p><code>ReqSocket</code> is similar to a <code>PushSocket</code> in that it round-robins messages
to connected <code>RepSocket</code>s, however it differs in that this communication is
bi-directional, every <code>req.send()</code> <em>must</em> provide a callback which is invoked
when the <code>RepSocket</code> replies.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> axon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'axon'</span>);
<span class="hljs-keyword">var</span> sock = axon.socket(<span class="hljs-string">'req'</span>);

sock.bind(<span class="hljs-number">3000</span>);

sock.send(img, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)</span>{

});
</code></pre>
<p><code>RepSocket</code>s receive a <code>reply</code> callback that is used to respond to the request,
you may have several of these nodes.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> axon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'axon'</span>);
<span class="hljs-keyword">var</span> sock = axon.socket(<span class="hljs-string">'rep'</span>);

sock.connect(<span class="hljs-number">3000</span>);

sock.on(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">img, reply</span>)</span>{
  <span class="hljs-comment">// resize the image</span>
  reply(img);
});
</code></pre>
<p>Like other sockets you may provide multiple arguments or an array of arguments,
followed by the callbacks. For example here we provide a task name of &quot;resize&quot;
to facilitate multiple tasks over a single socket:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> axon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'axon'</span>);
<span class="hljs-keyword">var</span> sock = axon.socket(<span class="hljs-string">'req'</span>);

sock.bind(<span class="hljs-number">3000</span>);

sock.send(<span class="hljs-string">'resize'</span>, img, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)</span>{

});
</code></pre>
<p>Respond to the &quot;resize&quot; task:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> axon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'axon'</span>);
<span class="hljs-keyword">var</span> sock = axon.socket(<span class="hljs-string">'rep'</span>);

sock.connect(<span class="hljs-number">3000</span>);

sock.on(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">task, img, reply</span>)</span>{
  <span class="hljs-keyword">switch</span> (task) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'resize'</span>:
      <span class="hljs-comment">// resize the image</span>
      reply(img);
      <span class="hljs-keyword">break</span>;
  }
});
</code></pre>
<div class="pilwrap" id="pubemitter-subemitter">
  <h2>
    <a href="#pubemitter-subemitter" name="pubemitter-subemitter" class="pilcrow"></a>
PubEmitter / SubEmitter
  </h2>
</div>
<p><code>PubEmitter</code> and <code>SubEmitter</code> are higher-level <code>Pub</code> / <code>Sub</code> sockets, using the &quot;json&quot; codec to behave much like node's <code>EventEmitter</code>. When a <code>SubEmitter</code>'s <code>.on()</code> method is invoked, the event name is <code>.subscribe()</code>d for you. Each wildcard (<code>*</code>) or regexp capture group is passed to the callback along with regular message arguments.</p>
<p>app.js:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> axon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'axon'</span>);
<span class="hljs-keyword">var</span> sock = axon.socket(<span class="hljs-string">'pub-emitter'</span>);

sock.connect(<span class="hljs-number">3000</span>);

setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  sock.emit(<span class="hljs-string">'login'</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">'tobi'</span> });
}, <span class="hljs-number">500</span>);
</code></pre>
<p>logger.js:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> axon = <span class="hljs-built_in">require</span>(<span class="hljs-string">'axon'</span>);
<span class="hljs-keyword">var</span> sock = axon.socket(<span class="hljs-string">'sub-emitter'</span>);

sock.bind(<span class="hljs-number">3000</span>);

sock.on(<span class="hljs-string">'user:login'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">user</span>)</span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'%s signed in'</span>, user.name);
});

sock.on(<span class="hljs-string">'user:*'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">action, user</span>)</span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'%s %s'</span>, user.name, action);
});

sock.on(<span class="hljs-string">'*'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);
});
</code></pre>
<div class="pilwrap" id="socket-options">
  <h2>
    <a href="#socket-options" name="socket-options" class="pilcrow"></a>
Socket Options
  </h2>
</div>
<p>Every socket has associated options that can be configured via <code>get/set</code>.</p>
<ul>
<li><code>identity</code> - the &quot;name&quot; of the socket that uniqued identifies it.</li>
<li><code>retry timeout</code> - connection retry timeout in milliseconds [100]</li>
<li><code>retry max timeout</code> - the cap for retry timeout length in milliseconds [5000]</li>
<li><code>hwm</code> - the high water mark threshold for queues [Infinity]</li>
</ul>
<div class="pilwrap" id="binding-connecting">
  <h2>
    <a href="#binding-connecting" name="binding-connecting" class="pilcrow"></a>
Binding / Connecting
  </h2>
</div>
<p>In addition to passing a portno, binding to INADDR_ANY by default, you
may also specify the hostname via <code>.bind(port, host)</code>, another alternative
is to specify the url much like zmq via <code>tcp://&lt;hostname&gt;:&lt;portno&gt;</code>, thus
the following are equivalent:</p>
<pre><code>sock.bind(3000)
sock.bind(3000, '0.0.0.0')
sock.bind('tcp://0.0.0.0:3000')

sock.connect(3000)
sock.connect(3000, '0.0.0.0')
sock.connect('tcp://0.0.0.0:3000')
</code></pre>
<p>You may also use unix domain sockets:</p>
<pre><code>sock.bind('unix:///some/path')
sock.connect('unix:///some/path')
</code></pre>
<div class="pilwrap" id="protocol">
  <h2>
    <a href="#protocol" name="protocol" class="pilcrow"></a>
Protocol
  </h2>
</div>
<p>Axon 2.x uses the extremely simple <a href="https://github.com/visionmedia/node-amp">AMP</a> protocol to send messages on the wire. Codecs are no longer required as they were in Axon 1.x.</p>
<div class="pilwrap" id="performance">
  <h2>
    <a href="#performance" name="performance" class="pilcrow"></a>
Performance
  </h2>
</div>
<p>Preliminary benchmarks on my Macbook Pro based on 10 messages
per tick as a realistic production application would likely have
even less than this. &quot;better&quot; numbers may be acheived with batching
and a larger messages/tick count however this is not realistic.</p>
<p>64 byte messages:</p>
<pre><code>
      min: 47,169 ops/s
     mean: 465,127 ops/s
   median: 500,000 ops/s
    total: 2,325,636 ops in 5s
  through: 28.39 mb/s

</code></pre>
<p>1k messages:</p>
<pre><code>
      min: 48,076 ops/s
     mean: 120,253 ops/s
   median: 121,951 ops/s
    total: 601,386 ops in 5.001s
  through: 117.43 mb/s

</code></pre>
<p>8k messages:</p>
<pre><code>
      min: 36,496 ops/s
     mean: 53,194 ops/s
   median: 50,505 ops/s
    total: 266,506 ops in 5.01s
  through: 405.84 mb/s

</code></pre>
<p>32k messages:</p>
<pre><code>
      min: 12,077 ops/s
     mean: 14,792 ops/s
   median: 16,233 ops/s
    total: 74,186 ops in 5.015s
  through: 462.28 mb/s

</code></pre>
<div class="pilwrap" id="whats-it-good-for">
  <h2>
    <a href="#whats-it-good-for" name="whats-it-good-for" class="pilcrow"></a>
What's it good for?
  </h2>
</div>
<p>Axon are not meant to combat zeromq nor provide feature parity,
but provide a nice solution when you don't need the insane
nanosecond latency or language interoperability that zeromq provides
as axon do not rely on any third-party compiled libraries.</p>
<div class="pilwrap" id="running-tests">
  <h2>
    <a href="#running-tests" name="running-tests" class="pilcrow"></a>
Running tests
  </h2>
</div>
<pre><code>$ npm install
$ make test
</code></pre>
<div class="pilwrap" id="authors">
  <h2>
    <a href="#authors" name="authors" class="pilcrow"></a>
Authors
  </h2>
</div>
<ul>
<li><a href="http://github.com/visionmedia">visionmedia</a></li>
<li><a href="https://github.com/gjohnson">gjohnson</a></li>
</ul>
<div class="pilwrap" id="links">
  <h2>
    <a href="#links" name="links" class="pilcrow"></a>
Links
  </h2>
</div>
<ul>
<li><a href="https://vimeo.com/45818408">Screencast</a></li>
<li><a href="https://github.com/visionmedia/axon-rpc">Axon RPC</a></li>
</ul>
<div class="pilwrap" id="license">
  <h2>
    <a href="#license" name="license" class="pilcrow"></a>
License
  </h2>
</div>
<p>MIT</p>
</div>
  </div>
</body>
</html>
